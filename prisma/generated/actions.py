# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse
from ._constants import CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class CabinetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Cabinet]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Cabinet.prisma().query_raw(
            'SELECT * FROM Cabinet WHERE id = $1',
            'bbadfchfja',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Cabinet
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Cabinet.prisma().query_first(
            'SELECT * FROM Cabinet WHERE number = $1',
            'dhheabfhf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.CabinetCreateInput,
        include: Optional[types.CabinetInclude] = None
    ) -> _PrismaModelT:
        """Create a new Cabinet record.

        Parameters
        ----------
        data
            Cabinet record data
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The created Cabinet record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Cabinet record from just the required fields
        cabinet = await Cabinet.prisma().create(
            data={
                # data to create a Cabinet record
                'id': 'ggciceaie',
                'number': 'bbehjachib',
                'officeId': 'cadfabfehe',
                'creatorId': 'dgiiaaijj',
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.CabinetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Cabinet records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Cabinet record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Cabinet.prisma().create_many(
            data=[
                {
                    # data to create a Cabinet record
                    'id': 'bfaiacjjfc',
                    'number': 'eigcfgbif',
                    'officeId': 'bagcfbhiig',
                    'creatorId': 'cghideieh',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Cabinet record
                    'id': 'biabhbdai',
                    'number': 'idghgaicb',
                    'officeId': 'fjfddhigg',
                    'creatorId': 'hjaecfifb',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.CabinetWhereUniqueInput,
        include: Optional[types.CabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Cabinet record.

        Parameters
        ----------
        where
            Cabinet filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The deleted Cabinet record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cabinet = await Cabinet.prisma().delete(
            where={
                'id': 'cbbbjbfcii',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.CabinetWhereUniqueInput,
        include: Optional[types.CabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Cabinet record.

        Parameters
        ----------
        where
            Cabinet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The found Cabinet record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cabinet = await Cabinet.prisma().find_unique(
            where={
                'id': 'bbejhfidcb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.CabinetWhereUniqueInput,
        include: Optional[types.CabinetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Cabinet record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Cabinet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The found Cabinet record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cabinet = await Cabinet.prisma().find_unique_or_raise(
            where={
                'id': 'bgeecijdgg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
        include: Optional[types.CabinetInclude] = None,
        order: Optional[Union[types.CabinetOrderByInput, List[types.CabinetOrderByInput]]] = None,
        distinct: Optional[List[types.CabinetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Cabinet records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Cabinet records returned
        skip
            Ignore the first N results
        where
            Cabinet filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Cabinet model
        order
            Order the returned Cabinet records by any field
        distinct
            Filter Cabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Cabinet]
            The list of all Cabinet records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Cabinet records
        cabinets = await Cabinet.prisma().find_many(take=10)

        # find the first 5 Cabinet records ordered by the officeId field
        cabinets = await Cabinet.prisma().find_many(
            take=5,
            order={
                'officeId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
        include: Optional[types.CabinetInclude] = None,
        order: Optional[Union[types.CabinetOrderByInput, List[types.CabinetOrderByInput]]] = None,
        distinct: Optional[List[types.CabinetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Cabinet record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Cabinet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Cabinet model
        order
            Order the returned Cabinet records by any field
        distinct
            Filter Cabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Cabinet
            The first Cabinet record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Cabinet record ordered by the createdAt field
        cabinet = await Cabinet.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
        include: Optional[types.CabinetInclude] = None,
        order: Optional[Union[types.CabinetOrderByInput, List[types.CabinetOrderByInput]]] = None,
        distinct: Optional[List[types.CabinetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Cabinet record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Cabinet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Cabinet model
        order
            Order the returned Cabinet records by any field
        distinct
            Filter Cabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Cabinet
            The first Cabinet record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Cabinet record ordered by the creatorId field
        cabinet = await Cabinet.prisma().find_first_or_raise(
            skip=1,
            order={
                'creatorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.CabinetUpdateInput,
        where: types.CabinetWhereUniqueInput,
        include: Optional[types.CabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Cabinet record.

        Parameters
        ----------
        data
            Cabinet record data specifying what to update
        where
            Cabinet filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The updated Cabinet record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        cabinet = await Cabinet.prisma().update(
            where={
                'id': 'bdiicjafbj',
            },
            data={
                # data to update the Cabinet record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.CabinetWhereUniqueInput,
        data: types.CabinetUpsertInput,
        include: Optional[types.CabinetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Cabinet filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Cabinet model

        Returns
        -------
        prisma.models.Cabinet
            The created or updated Cabinet record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        cabinet = await Cabinet.prisma().upsert(
            where={
                'id': 'bgehebiafc',
            },
            data={
                'create': {
                    'id': 'bgehebiafc',
                    'number': 'idghgaicb',
                    'officeId': 'fjfddhigg',
                    'creatorId': 'hjaecfifb',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'number': 'idghgaicb',
                    'officeId': 'fjfddhigg',
                    'creatorId': 'hjaecfifb',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.CabinetUpdateManyMutationInput,
        where: types.CabinetWhereInput,
    ) -> int:
        """Update multiple Cabinet records

        Parameters
        ----------
        data
            Cabinet data to update the selected Cabinet records to
        where
            Filter to select the Cabinet records to update

        Returns
        -------
        int
            The total number of Cabinet records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Cabinet records
        total = await Cabinet.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Cabinet records present in the database

        Parameters
        ----------
        select
            Select the Cabinet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Cabinet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CabinetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Cabinet.prisma().count()

        # results: prisma.types.CabinetCountAggregateOutput
        results = await Cabinet.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.CabinetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
    ) -> types.CabinetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.CabinetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.CabinetWhereInput] = None,
        cursor: Optional[types.CabinetWhereUniqueInput] = None,
    ) -> Union[int, types.CabinetCountAggregateOutput]:
        """Count the number of Cabinet records present in the database

        Parameters
        ----------
        select
            Select the Cabinet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Cabinet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.CabinetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Cabinet.prisma().count()

        # results: prisma.types.CabinetCountAggregateOutput
        results = await Cabinet.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.CabinetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.CabinetWhereInput] = None
    ) -> int:
        """Delete multiple Cabinet records.

        Parameters
        ----------
        where
            Optional Cabinet filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Cabinet records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Cabinet records
        total = await Cabinet.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.CabinetScalarFieldKeys'],
        *,
        where: Optional['types.CabinetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.CabinetAvgAggregateInput'] = None,
        sum: Optional['types.CabinetSumAggregateInput'] = None,
        min: Optional['types.CabinetMinAggregateInput'] = None,
        max: Optional['types.CabinetMaxAggregateInput'] = None,
        having: Optional['types.CabinetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.CabinetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.CabinetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.CabinetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.CabinetGroupByOutput']:
        """Group Cabinet records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Cabinet fields to group records by
        where
            Cabinet filter to select records
        take
            Limit the maximum number of Cabinet records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.CabinetGroupByOutput]
            A list of dictionaries representing the Cabinet record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Cabinet records by id values
        # and count how many records are in each group
        results = await Cabinet.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClientActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Client]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Client.prisma().query_raw(
            'SELECT * FROM Client WHERE id = $1',
            'bghffegacj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Client
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Client.prisma().query_first(
            'SELECT * FROM Client WHERE telegramId = $1',
            'bhghchehcc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ClientCreateInput,
        include: Optional[types.ClientInclude] = None
    ) -> _PrismaModelT:
        """Create a new Client record.

        Parameters
        ----------
        data
            Client record data
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The created Client record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Client record from just the required fields
        client = await Client.prisma().create(
            data={
                # data to create a Client record
                'id': 'dcgchcbbf',
                'telegramId': 'bdedcabahc',
                'firstName': 'ghfhiafcb',
                'lastName': 'heejgedji',
                'birthDate': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClientCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Client records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Client record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Client.prisma().create_many(
            data=[
                {
                    # data to create a Client record
                    'id': 'bjgjgibgbf',
                    'telegramId': 'bbbgbhfjge',
                    'firstName': 'igbehcbab',
                    'lastName': 'bdadaadhag',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Client record
                    'id': 'bgiggdidbf',
                    'telegramId': 'caaaedabfc',
                    'firstName': 'bigibebcib',
                    'lastName': 'bigaiehgcc',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Client record.

        Parameters
        ----------
        where
            Client filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The deleted Client record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().delete(
            where={
                'id': 'beeifcbebf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Client record.

        Parameters
        ----------
        where
            Client filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The found Client record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().find_unique(
            where={
                'id': 'bgcigfahea',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Client record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Client filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The found Client record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().find_unique_or_raise(
            where={
                'id': 'bcejgaggif',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Client records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Client records returned
        skip
            Ignore the first N results
        where
            Client filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Client]
            The list of all Client records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Client records
        clients = await Client.prisma().find_many(take=10)

        # find the first 5 Client records ordered by the firstName field
        clients = await Client.prisma().find_many(
            take=5,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Client record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Client filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Client
            The first Client record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Client record ordered by the lastName field
        client = await Client.prisma().find_first(
            skip=1,
            order={
                'lastName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
        include: Optional[types.ClientInclude] = None,
        order: Optional[Union[types.ClientOrderByInput, List[types.ClientOrderByInput]]] = None,
        distinct: Optional[List[types.ClientScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Client record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Client filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Client model
        order
            Order the returned Client records by any field
        distinct
            Filter Client records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Client
            The first Client record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Client record ordered by the middleName field
        client = await Client.prisma().find_first_or_raise(
            skip=1,
            order={
                'middleName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClientUpdateInput,
        where: types.ClientWhereUniqueInput,
        include: Optional[types.ClientInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Client record.

        Parameters
        ----------
        data
            Client record data specifying what to update
        where
            Client filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The updated Client record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        client = await Client.prisma().update(
            where={
                'id': 'idfjadbcc',
            },
            data={
                # data to update the Client record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClientWhereUniqueInput,
        data: types.ClientUpsertInput,
        include: Optional[types.ClientInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Client filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Client model

        Returns
        -------
        prisma.models.Client
            The created or updated Client record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        client = await Client.prisma().upsert(
            where={
                'id': 'hgdhbjhhj',
            },
            data={
                'create': {
                    'id': 'hgdhbjhhj',
                    'telegramId': 'caaaedabfc',
                    'firstName': 'bigibebcib',
                    'lastName': 'bigaiehgcc',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'telegramId': 'caaaedabfc',
                    'firstName': 'bigibebcib',
                    'lastName': 'bigaiehgcc',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClientUpdateManyMutationInput,
        where: types.ClientWhereInput,
    ) -> int:
        """Update multiple Client records

        Parameters
        ----------
        data
            Client data to update the selected Client records to
        where
            Filter to select the Client records to update

        Returns
        -------
        int
            The total number of Client records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Client records
        total = await Client.prisma().update_many(
            data={
                'birthDate': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Client records present in the database

        Parameters
        ----------
        select
            Select the Client fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Client filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Client.prisma().count()

        # results: prisma.types.ClientCountAggregateOutput
        results = await Client.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClientCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> types.ClientCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClientCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientWhereInput] = None,
        cursor: Optional[types.ClientWhereUniqueInput] = None,
    ) -> Union[int, types.ClientCountAggregateOutput]:
        """Count the number of Client records present in the database

        Parameters
        ----------
        select
            Select the Client fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Client filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Client.prisma().count()

        # results: prisma.types.ClientCountAggregateOutput
        results = await Client.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClientCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClientWhereInput] = None
    ) -> int:
        """Delete multiple Client records.

        Parameters
        ----------
        where
            Optional Client filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Client records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Client records
        total = await Client.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClientScalarFieldKeys'],
        *,
        where: Optional['types.ClientWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClientAvgAggregateInput'] = None,
        sum: Optional['types.ClientSumAggregateInput'] = None,
        min: Optional['types.ClientMinAggregateInput'] = None,
        max: Optional['types.ClientMaxAggregateInput'] = None,
        having: Optional['types.ClientScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClientCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClientScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ClientScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ClientGroupByOutput']:
        """Group Client records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Client fields to group records by
        where
            Client filter to select records
        take
            Limit the maximum number of Client records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClientGroupByOutput]
            A list of dictionaries representing the Client record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Client records by deletedAt values
        # and count how many records are in each group
        results = await Client.prisma().group_by(
            ['deletedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ClientHistoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ClientHistory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ClientHistory.prisma().query_raw(
            'SELECT * FROM ClientHistory WHERE id = $1',
            'ecjjjfbae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ClientHistory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ClientHistory.prisma().query_first(
            'SELECT * FROM ClientHistory WHERE clientId = $1',
            'bhhfibbigf',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ClientHistoryCreateInput,
        include: Optional[types.ClientHistoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new ClientHistory record.

        Parameters
        ----------
        data
            ClientHistory record data
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The created ClientHistory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ClientHistory record from just the required fields
        clienthistory = await ClientHistory.prisma().create(
            data={
                # data to create a ClientHistory record
                'id': 'ijdbeffgg',
                'clientId': 'jjfeafhfj',
                'serviceId': 'cbachdgfce',
                'date': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ClientHistoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ClientHistory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ClientHistory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ClientHistory.prisma().create_many(
            data=[
                {
                    # data to create a ClientHistory record
                    'id': 'chbfcacbd',
                    'clientId': 'efggddide',
                    'serviceId': 'caficfigfb',
                    'date': datetime.datetime.utcnow(),
                },
                {
                    # data to create a ClientHistory record
                    'id': 'bfidgijfjc',
                    'clientId': 'ihieecagf',
                    'serviceId': 'bghfciaafe',
                    'date': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ClientHistoryWhereUniqueInput,
        include: Optional[types.ClientHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ClientHistory record.

        Parameters
        ----------
        where
            ClientHistory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The deleted ClientHistory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clienthistory = await ClientHistory.prisma().delete(
            where={
                'id': 'bgchfhgceh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ClientHistoryWhereUniqueInput,
        include: Optional[types.ClientHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ClientHistory record.

        Parameters
        ----------
        where
            ClientHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The found ClientHistory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clienthistory = await ClientHistory.prisma().find_unique(
            where={
                'id': 'cafeiaccbc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ClientHistoryWhereUniqueInput,
        include: Optional[types.ClientHistoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ClientHistory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ClientHistory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The found ClientHistory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clienthistory = await ClientHistory.prisma().find_unique_or_raise(
            where={
                'id': 'gaddfhfh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
        include: Optional[types.ClientHistoryInclude] = None,
        order: Optional[Union[types.ClientHistoryOrderByInput, List[types.ClientHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ClientHistoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ClientHistory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ClientHistory records returned
        skip
            Ignore the first N results
        where
            ClientHistory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClientHistory model
        order
            Order the returned ClientHistory records by any field
        distinct
            Filter ClientHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ClientHistory]
            The list of all ClientHistory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ClientHistory records
        clienthistorys = await ClientHistory.prisma().find_many(take=10)

        # find the first 5 ClientHistory records ordered by the serviceId field
        clienthistorys = await ClientHistory.prisma().find_many(
            take=5,
            order={
                'serviceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
        include: Optional[types.ClientHistoryInclude] = None,
        order: Optional[Union[types.ClientHistoryOrderByInput, List[types.ClientHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ClientHistoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ClientHistory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClientHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClientHistory model
        order
            Order the returned ClientHistory records by any field
        distinct
            Filter ClientHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClientHistory
            The first ClientHistory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClientHistory record ordered by the date field
        clienthistory = await ClientHistory.prisma().find_first(
            skip=1,
            order={
                'date': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
        include: Optional[types.ClientHistoryInclude] = None,
        order: Optional[Union[types.ClientHistoryOrderByInput, List[types.ClientHistoryOrderByInput]]] = None,
        distinct: Optional[List[types.ClientHistoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ClientHistory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ClientHistory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ClientHistory model
        order
            Order the returned ClientHistory records by any field
        distinct
            Filter ClientHistory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ClientHistory
            The first ClientHistory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ClientHistory record ordered by the feedbackId field
        clienthistory = await ClientHistory.prisma().find_first_or_raise(
            skip=1,
            order={
                'feedbackId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ClientHistoryUpdateInput,
        where: types.ClientHistoryWhereUniqueInput,
        include: Optional[types.ClientHistoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ClientHistory record.

        Parameters
        ----------
        data
            ClientHistory record data specifying what to update
        where
            ClientHistory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The updated ClientHistory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        clienthistory = await ClientHistory.prisma().update(
            where={
                'id': 'gieegcbeg',
            },
            data={
                # data to update the ClientHistory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ClientHistoryWhereUniqueInput,
        data: types.ClientHistoryUpsertInput,
        include: Optional[types.ClientHistoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ClientHistory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ClientHistory model

        Returns
        -------
        prisma.models.ClientHistory
            The created or updated ClientHistory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        clienthistory = await ClientHistory.prisma().upsert(
            where={
                'id': 'bgcffadich',
            },
            data={
                'create': {
                    'id': 'bgcffadich',
                    'clientId': 'ihieecagf',
                    'serviceId': 'bghfciaafe',
                    'date': datetime.datetime.utcnow(),
                },
                'update': {
                    'clientId': 'ihieecagf',
                    'serviceId': 'bghfciaafe',
                    'date': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ClientHistoryUpdateManyMutationInput,
        where: types.ClientHistoryWhereInput,
    ) -> int:
        """Update multiple ClientHistory records

        Parameters
        ----------
        data
            ClientHistory data to update the selected ClientHistory records to
        where
            Filter to select the ClientHistory records to update

        Returns
        -------
        int
            The total number of ClientHistory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ClientHistory records
        total = await ClientHistory.prisma().update_many(
            data={
                'id': 'fcbichhci'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ClientHistory records present in the database

        Parameters
        ----------
        select
            Select the ClientHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClientHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClientHistory.prisma().count()

        # results: prisma.types.ClientHistoryCountAggregateOutput
        results = await ClientHistory.prisma().count(
            select={
                '_all': True,
                'clientId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ClientHistoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
    ) -> types.ClientHistoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ClientHistoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ClientHistoryWhereInput] = None,
        cursor: Optional[types.ClientHistoryWhereUniqueInput] = None,
    ) -> Union[int, types.ClientHistoryCountAggregateOutput]:
        """Count the number of ClientHistory records present in the database

        Parameters
        ----------
        select
            Select the ClientHistory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ClientHistory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ClientHistoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ClientHistory.prisma().count()

        # results: prisma.types.ClientHistoryCountAggregateOutput
        results = await ClientHistory.prisma().count(
            select={
                '_all': True,
                'serviceId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ClientHistoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ClientHistoryWhereInput] = None
    ) -> int:
        """Delete multiple ClientHistory records.

        Parameters
        ----------
        where
            Optional ClientHistory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ClientHistory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ClientHistory records
        total = await ClientHistory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ClientHistoryScalarFieldKeys'],
        *,
        where: Optional['types.ClientHistoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ClientHistoryAvgAggregateInput'] = None,
        sum: Optional['types.ClientHistorySumAggregateInput'] = None,
        min: Optional['types.ClientHistoryMinAggregateInput'] = None,
        max: Optional['types.ClientHistoryMaxAggregateInput'] = None,
        having: Optional['types.ClientHistoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ClientHistoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ClientHistoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ClientHistoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ClientHistoryGroupByOutput']:
        """Group ClientHistory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ClientHistory fields to group records by
        where
            ClientHistory filter to select records
        take
            Limit the maximum number of ClientHistory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ClientHistoryGroupByOutput]
            A list of dictionaries representing the ClientHistory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ClientHistory records by date values
        # and count how many records are in each group
        results = await ClientHistory.prisma().group_by(
            ['date'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DepartmentActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Department]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Department.prisma().query_raw(
            'SELECT * FROM Department WHERE id = $1',
            'bcggadccgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Department
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Department.prisma().query_first(
            'SELECT * FROM Department WHERE name = $1',
            'jdcfdcgc',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DepartmentCreateInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> _PrismaModelT:
        """Create a new Department record.

        Parameters
        ----------
        data
            Department record data
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The created Department record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Department record from just the required fields
        department = await Department.prisma().create(
            data={
                # data to create a Department record
                'id': 'cafdaehjid',
                'name': 'gifdddbia',
                'description': 'bchehecef',
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DepartmentCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Department records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Department record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Department.prisma().create_many(
            data=[
                {
                    # data to create a Department record
                    'id': 'jeijcbhfe',
                    'name': 'bjgejjabff',
                    'description': 'bcciijbibg',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Department record
                    'id': 'cffcachfd',
                    'name': 'bccdfhdigc',
                    'description': 'febcgjbfj',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Department record.

        Parameters
        ----------
        where
            Department filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The deleted Department record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().delete(
            where={
                'id': 'bageiegghg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Department record.

        Parameters
        ----------
        where
            Department filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The found Department record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().find_unique(
            where={
                'id': 'faidicegb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Department record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Department filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The found Department record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().find_unique_or_raise(
            where={
                'id': 'bacecgfhbe',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Department records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Department records returned
        skip
            Ignore the first N results
        where
            Department filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Department]
            The list of all Department records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Department records
        departments = await Department.prisma().find_many(take=10)

        # find the first 5 Department records ordered by the description field
        departments = await Department.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Department record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Department filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Department
            The first Department record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Department record ordered by the createdAt field
        department = await Department.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
        include: Optional[types.DepartmentInclude] = None,
        order: Optional[Union[types.DepartmentOrderByInput, List[types.DepartmentOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Department record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Department filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Department model
        order
            Order the returned Department records by any field
        distinct
            Filter Department records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Department
            The first Department record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Department record ordered by the updatedAt field
        department = await Department.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DepartmentUpdateInput,
        where: types.DepartmentWhereUniqueInput,
        include: Optional[types.DepartmentInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Department record.

        Parameters
        ----------
        data
            Department record data specifying what to update
        where
            Department filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The updated Department record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        department = await Department.prisma().update(
            where={
                'id': 'ihcahiead',
            },
            data={
                # data to update the Department record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DepartmentWhereUniqueInput,
        data: types.DepartmentUpsertInput,
        include: Optional[types.DepartmentInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Department filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Department model

        Returns
        -------
        prisma.models.Department
            The created or updated Department record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        department = await Department.prisma().upsert(
            where={
                'id': 'biheheiajg',
            },
            data={
                'create': {
                    'id': 'biheheiajg',
                    'name': 'bccdfhdigc',
                    'description': 'febcgjbfj',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'name': 'bccdfhdigc',
                    'description': 'febcgjbfj',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DepartmentUpdateManyMutationInput,
        where: types.DepartmentWhereInput,
    ) -> int:
        """Update multiple Department records

        Parameters
        ----------
        data
            Department data to update the selected Department records to
        where
            Filter to select the Department records to update

        Returns
        -------
        int
            The total number of Department records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Department records
        total = await Department.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Department records present in the database

        Parameters
        ----------
        select
            Select the Department fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Department filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Department.prisma().count()

        # results: prisma.types.DepartmentCountAggregateOutput
        results = await Department.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DepartmentCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> types.DepartmentCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DepartmentCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentWhereInput] = None,
        cursor: Optional[types.DepartmentWhereUniqueInput] = None,
    ) -> Union[int, types.DepartmentCountAggregateOutput]:
        """Count the number of Department records present in the database

        Parameters
        ----------
        select
            Select the Department fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Department filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Department.prisma().count()

        # results: prisma.types.DepartmentCountAggregateOutput
        results = await Department.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DepartmentCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DepartmentWhereInput] = None
    ) -> int:
        """Delete multiple Department records.

        Parameters
        ----------
        where
            Optional Department filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Department records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Department records
        total = await Department.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DepartmentScalarFieldKeys'],
        *,
        where: Optional['types.DepartmentWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DepartmentAvgAggregateInput'] = None,
        sum: Optional['types.DepartmentSumAggregateInput'] = None,
        min: Optional['types.DepartmentMinAggregateInput'] = None,
        max: Optional['types.DepartmentMaxAggregateInput'] = None,
        having: Optional['types.DepartmentScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DepartmentCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DepartmentScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DepartmentScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DepartmentGroupByOutput']:
        """Group Department records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Department fields to group records by
        where
            Department filter to select records
        take
            Limit the maximum number of Department records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DepartmentGroupByOutput]
            A list of dictionaries representing the Department record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Department records by description values
        # and count how many records are in each group
        results = await Department.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class DepartmentUserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.DepartmentUser]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await DepartmentUser.prisma().query_raw(
            'SELECT * FROM DepartmentUser WHERE userId = $1',
            'jbgijghgb',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.DepartmentUser
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await DepartmentUser.prisma().query_first(
            'SELECT * FROM DepartmentUser WHERE departmentId = $1',
            'hgjcghfbi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.DepartmentUserCreateInput,
        include: Optional[types.DepartmentUserInclude] = None
    ) -> _PrismaModelT:
        """Create a new DepartmentUser record.

        Parameters
        ----------
        data
            DepartmentUser record data
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The created DepartmentUser record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a DepartmentUser record from just the required fields
        departmentuser = await DepartmentUser.prisma().create(
            data={
                # data to create a DepartmentUser record
                'userId': 'icadbcehj',
                'departmentId': 'jchciaee',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.DepartmentUserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple DepartmentUser records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of DepartmentUser record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await DepartmentUser.prisma().create_many(
            data=[
                {
                    # data to create a DepartmentUser record
                    'userId': 'deeificjd',
                    'departmentId': 'bbcbhebbda',
                },
                {
                    # data to create a DepartmentUser record
                    'userId': 'bejfijgcfb',
                    'departmentId': 'caifcbgii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.DepartmentUserWhereUniqueInput,
        include: Optional[types.DepartmentUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single DepartmentUser record.

        Parameters
        ----------
        where
            DepartmentUser filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The deleted DepartmentUser record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmentuser = await DepartmentUser.prisma().delete(
            where={
                # DepartmentUser where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.DepartmentUserWhereUniqueInput,
        include: Optional[types.DepartmentUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique DepartmentUser record.

        Parameters
        ----------
        where
            DepartmentUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The found DepartmentUser record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmentuser = await DepartmentUser.prisma().find_unique(
            where={
                # DepartmentUser where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.DepartmentUserWhereUniqueInput,
        include: Optional[types.DepartmentUserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique DepartmentUser record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            DepartmentUser filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The found DepartmentUser record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmentuser = await DepartmentUser.prisma().find_unique_or_raise(
            where={
                # DepartmentUser where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
        include: Optional[types.DepartmentUserInclude] = None,
        order: Optional[Union[types.DepartmentUserOrderByInput, List[types.DepartmentUserOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentUserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple DepartmentUser records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of DepartmentUser records returned
        skip
            Ignore the first N results
        where
            DepartmentUser filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentUser model
        order
            Order the returned DepartmentUser records by any field
        distinct
            Filter DepartmentUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.DepartmentUser]
            The list of all DepartmentUser records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 DepartmentUser records
        departmentusers = await DepartmentUser.prisma().find_many(take=10)

        # find the first 5 DepartmentUser records ordered by the userId field
        departmentusers = await DepartmentUser.prisma().find_many(
            take=5,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
        include: Optional[types.DepartmentUserInclude] = None,
        order: Optional[Union[types.DepartmentUserOrderByInput, List[types.DepartmentUserOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentUserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single DepartmentUser record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DepartmentUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentUser model
        order
            Order the returned DepartmentUser records by any field
        distinct
            Filter DepartmentUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DepartmentUser
            The first DepartmentUser record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DepartmentUser record ordered by the departmentId field
        departmentuser = await DepartmentUser.prisma().find_first(
            skip=1,
            order={
                'departmentId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
        include: Optional[types.DepartmentUserInclude] = None,
        order: Optional[Union[types.DepartmentUserOrderByInput, List[types.DepartmentUserOrderByInput]]] = None,
        distinct: Optional[List[types.DepartmentUserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single DepartmentUser record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            DepartmentUser filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned DepartmentUser model
        order
            Order the returned DepartmentUser records by any field
        distinct
            Filter DepartmentUser records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.DepartmentUser
            The first DepartmentUser record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second DepartmentUser record ordered by the userId field
        departmentuser = await DepartmentUser.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.DepartmentUserUpdateInput,
        where: types.DepartmentUserWhereUniqueInput,
        include: Optional[types.DepartmentUserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single DepartmentUser record.

        Parameters
        ----------
        data
            DepartmentUser record data specifying what to update
        where
            DepartmentUser filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The updated DepartmentUser record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        departmentuser = await DepartmentUser.prisma().update(
            where={
                # DepartmentUser where unique filter

            },
            data={
                # data to update the DepartmentUser record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.DepartmentUserWhereUniqueInput,
        data: types.DepartmentUserUpsertInput,
        include: Optional[types.DepartmentUserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            DepartmentUser filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned DepartmentUser model

        Returns
        -------
        prisma.models.DepartmentUser
            The created or updated DepartmentUser record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        departmentuser = await DepartmentUser.prisma().upsert(
            where={
                # DepartmentUser where unique filter
            },
            data={
                'create': {
                    # DepartmentUser data to be set if the record does not exist
                },
                'update': {
                    # DepartmentUser data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.DepartmentUserUpdateManyMutationInput,
        where: types.DepartmentUserWhereInput,
    ) -> int:
        """Update multiple DepartmentUser records

        Parameters
        ----------
        data
            DepartmentUser data to update the selected DepartmentUser records to
        where
            Filter to select the DepartmentUser records to update

        Returns
        -------
        int
            The total number of DepartmentUser records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all DepartmentUser records
        total = await DepartmentUser.prisma().update_many(
            data={
                'departmentId': 'igaibbfgj'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of DepartmentUser records present in the database

        Parameters
        ----------
        select
            Select the DepartmentUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DepartmentUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DepartmentUser.prisma().count()

        # results: prisma.types.DepartmentUserCountAggregateOutput
        results = await DepartmentUser.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.DepartmentUserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
    ) -> types.DepartmentUserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.DepartmentUserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.DepartmentUserWhereInput] = None,
        cursor: Optional[types.DepartmentUserWhereUniqueInput] = None,
    ) -> Union[int, types.DepartmentUserCountAggregateOutput]:
        """Count the number of DepartmentUser records present in the database

        Parameters
        ----------
        select
            Select the DepartmentUser fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            DepartmentUser filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.DepartmentUserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await DepartmentUser.prisma().count()

        # results: prisma.types.DepartmentUserCountAggregateOutput
        results = await DepartmentUser.prisma().count(
            select={
                '_all': True,
                'departmentId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.DepartmentUserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.DepartmentUserWhereInput] = None
    ) -> int:
        """Delete multiple DepartmentUser records.

        Parameters
        ----------
        where
            Optional DepartmentUser filter to find the records to be deleted

        Returns
        -------
        int
            The total number of DepartmentUser records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all DepartmentUser records
        total = await DepartmentUser.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.DepartmentUserScalarFieldKeys'],
        *,
        where: Optional['types.DepartmentUserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.DepartmentUserAvgAggregateInput'] = None,
        sum: Optional['types.DepartmentUserSumAggregateInput'] = None,
        min: Optional['types.DepartmentUserMinAggregateInput'] = None,
        max: Optional['types.DepartmentUserMaxAggregateInput'] = None,
        having: Optional['types.DepartmentUserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.DepartmentUserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.DepartmentUserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.DepartmentUserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.DepartmentUserGroupByOutput']:
        """Group DepartmentUser records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar DepartmentUser fields to group records by
        where
            DepartmentUser filter to select records
        take
            Limit the maximum number of DepartmentUser records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.DepartmentUserGroupByOutput]
            A list of dictionaries representing the DepartmentUser record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group DepartmentUser records by userId values
        # and count how many records are in each group
        results = await DepartmentUser.prisma().group_by(
            ['userId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OfficeActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Office]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Office.prisma().query_raw(
            'SELECT * FROM Office WHERE id = $1',
            'bggajdcbbi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Office
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Office.prisma().query_first(
            'SELECT * FROM Office WHERE number = $1',
            'fcfhgbjed',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OfficeCreateInput,
        include: Optional[types.OfficeInclude] = None
    ) -> _PrismaModelT:
        """Create a new Office record.

        Parameters
        ----------
        data
            Office record data
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The created Office record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Office record from just the required fields
        office = await Office.prisma().create(
            data={
                # data to create a Office record
                'id': 'hdgcajhjg',
                'number': 'ejdjahicb',
                'address': 'gdjgigfgc',
                'updatedAt': datetime.datetime.utcnow(),
                'creatorId': 'gfeaahdeh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OfficeCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Office records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Office record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Office.prisma().create_many(
            data=[
                {
                    # data to create a Office record
                    'id': 'bjafcgbffc',
                    'number': 'hihegjif',
                    'address': 'bdjidcidac',
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'ifgaaagff',
                },
                {
                    # data to create a Office record
                    'id': 'befcddgjce',
                    'number': 'bfhdbjjgfd',
                    'address': 'cabdjadaji',
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'faajgfadf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OfficeWhereUniqueInput,
        include: Optional[types.OfficeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Office record.

        Parameters
        ----------
        where
            Office filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The deleted Office record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        office = await Office.prisma().delete(
            where={
                'id': 'biaagcedjc',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OfficeWhereUniqueInput,
        include: Optional[types.OfficeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Office record.

        Parameters
        ----------
        where
            Office filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The found Office record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        office = await Office.prisma().find_unique(
            where={
                'id': 'cahhaghecf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OfficeWhereUniqueInput,
        include: Optional[types.OfficeInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Office record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Office filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The found Office record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        office = await Office.prisma().find_unique_or_raise(
            where={
                'id': 'bghcbbcidi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
        include: Optional[types.OfficeInclude] = None,
        order: Optional[Union[types.OfficeOrderByInput, List[types.OfficeOrderByInput]]] = None,
        distinct: Optional[List[types.OfficeScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Office records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Office records returned
        skip
            Ignore the first N results
        where
            Office filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Office model
        order
            Order the returned Office records by any field
        distinct
            Filter Office records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Office]
            The list of all Office records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Office records
        offices = await Office.prisma().find_many(take=10)

        # find the first 5 Office records ordered by the address field
        offices = await Office.prisma().find_many(
            take=5,
            order={
                'address': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
        include: Optional[types.OfficeInclude] = None,
        order: Optional[Union[types.OfficeOrderByInput, List[types.OfficeOrderByInput]]] = None,
        distinct: Optional[List[types.OfficeScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Office record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Office filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Office model
        order
            Order the returned Office records by any field
        distinct
            Filter Office records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Office
            The first Office record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Office record ordered by the createdAt field
        office = await Office.prisma().find_first(
            skip=1,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
        include: Optional[types.OfficeInclude] = None,
        order: Optional[Union[types.OfficeOrderByInput, List[types.OfficeOrderByInput]]] = None,
        distinct: Optional[List[types.OfficeScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Office record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Office filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Office model
        order
            Order the returned Office records by any field
        distinct
            Filter Office records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Office
            The first Office record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Office record ordered by the updatedAt field
        office = await Office.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OfficeUpdateInput,
        where: types.OfficeWhereUniqueInput,
        include: Optional[types.OfficeInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Office record.

        Parameters
        ----------
        data
            Office record data specifying what to update
        where
            Office filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The updated Office record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        office = await Office.prisma().update(
            where={
                'id': 'jcgghhgdj',
            },
            data={
                # data to update the Office record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OfficeWhereUniqueInput,
        data: types.OfficeUpsertInput,
        include: Optional[types.OfficeInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Office filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Office model

        Returns
        -------
        prisma.models.Office
            The created or updated Office record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        office = await Office.prisma().upsert(
            where={
                'id': 'beehgcebbg',
            },
            data={
                'create': {
                    'id': 'beehgcebbg',
                    'number': 'bfhdbjjgfd',
                    'address': 'cabdjadaji',
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'faajgfadf',
                },
                'update': {
                    'number': 'bfhdbjjgfd',
                    'address': 'cabdjadaji',
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'faajgfadf',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OfficeUpdateManyMutationInput,
        where: types.OfficeWhereInput,
    ) -> int:
        """Update multiple Office records

        Parameters
        ----------
        data
            Office data to update the selected Office records to
        where
            Filter to select the Office records to update

        Returns
        -------
        int
            The total number of Office records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Office records
        total = await Office.prisma().update_many(
            data={
                'deletedAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Office records present in the database

        Parameters
        ----------
        select
            Select the Office fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Office filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OfficeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Office.prisma().count()

        # results: prisma.types.OfficeCountAggregateOutput
        results = await Office.prisma().count(
            select={
                '_all': True,
                'creatorId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OfficeCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
    ) -> types.OfficeCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OfficeCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OfficeWhereInput] = None,
        cursor: Optional[types.OfficeWhereUniqueInput] = None,
    ) -> Union[int, types.OfficeCountAggregateOutput]:
        """Count the number of Office records present in the database

        Parameters
        ----------
        select
            Select the Office fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Office filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OfficeCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Office.prisma().count()

        # results: prisma.types.OfficeCountAggregateOutput
        results = await Office.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OfficeCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OfficeWhereInput] = None
    ) -> int:
        """Delete multiple Office records.

        Parameters
        ----------
        where
            Optional Office filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Office records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Office records
        total = await Office.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OfficeScalarFieldKeys'],
        *,
        where: Optional['types.OfficeWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OfficeAvgAggregateInput'] = None,
        sum: Optional['types.OfficeSumAggregateInput'] = None,
        min: Optional['types.OfficeMinAggregateInput'] = None,
        max: Optional['types.OfficeMaxAggregateInput'] = None,
        having: Optional['types.OfficeScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OfficeCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OfficeScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OfficeScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OfficeGroupByOutput']:
        """Group Office records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Office fields to group records by
        where
            Office filter to select records
        take
            Limit the maximum number of Office records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OfficeGroupByOutput]
            A list of dictionaries representing the Office record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Office records by number values
        # and count how many records are in each group
        results = await Office.prisma().group_by(
            ['number'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class OpportunityActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Opportunity]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Opportunity.prisma().query_raw(
            'SELECT * FROM Opportunity WHERE id = $1',
            'bhdiaidiaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Opportunity
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Opportunity.prisma().query_first(
            'SELECT * FROM Opportunity WHERE name = $1',
            'deajegcfi',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.OpportunityCreateInput,
        include: Optional[types.OpportunityInclude] = None
    ) -> _PrismaModelT:
        """Create a new Opportunity record.

        Parameters
        ----------
        data
            Opportunity record data
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The created Opportunity record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Opportunity record from just the required fields
        opportunity = await Opportunity.prisma().create(
            data={
                # data to create a Opportunity record
                'id': 'gabahhhjf',
                'name': 'cjagadcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.OpportunityCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Opportunity records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Opportunity record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Opportunity.prisma().create_many(
            data=[
                {
                    # data to create a Opportunity record
                    'id': 'bifficggej',
                    'name': 'bgbbaajbic',
                },
                {
                    # data to create a Opportunity record
                    'id': 'eegghdhjb',
                    'name': 'daafgidjg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.OpportunityWhereUniqueInput,
        include: Optional[types.OpportunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Opportunity record.

        Parameters
        ----------
        where
            Opportunity filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The deleted Opportunity record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        opportunity = await Opportunity.prisma().delete(
            where={
                'id': 'gdcgcgagj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.OpportunityWhereUniqueInput,
        include: Optional[types.OpportunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Opportunity record.

        Parameters
        ----------
        where
            Opportunity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The found Opportunity record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        opportunity = await Opportunity.prisma().find_unique(
            where={
                'id': 'bhceabbgja',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.OpportunityWhereUniqueInput,
        include: Optional[types.OpportunityInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Opportunity record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Opportunity filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The found Opportunity record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        opportunity = await Opportunity.prisma().find_unique_or_raise(
            where={
                'id': 'ehabfhegh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
        include: Optional[types.OpportunityInclude] = None,
        order: Optional[Union[types.OpportunityOrderByInput, List[types.OpportunityOrderByInput]]] = None,
        distinct: Optional[List[types.OpportunityScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Opportunity records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Opportunity records returned
        skip
            Ignore the first N results
        where
            Opportunity filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Opportunity model
        order
            Order the returned Opportunity records by any field
        distinct
            Filter Opportunity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Opportunity]
            The list of all Opportunity records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Opportunity records
        opportunitys = await Opportunity.prisma().find_many(take=10)

        # find the first 5 Opportunity records ordered by the id field
        opportunitys = await Opportunity.prisma().find_many(
            take=5,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
        include: Optional[types.OpportunityInclude] = None,
        order: Optional[Union[types.OpportunityOrderByInput, List[types.OpportunityOrderByInput]]] = None,
        distinct: Optional[List[types.OpportunityScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Opportunity record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Opportunity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Opportunity model
        order
            Order the returned Opportunity records by any field
        distinct
            Filter Opportunity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Opportunity
            The first Opportunity record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Opportunity record ordered by the name field
        opportunity = await Opportunity.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
        include: Optional[types.OpportunityInclude] = None,
        order: Optional[Union[types.OpportunityOrderByInput, List[types.OpportunityOrderByInput]]] = None,
        distinct: Optional[List[types.OpportunityScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Opportunity record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Opportunity filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Opportunity model
        order
            Order the returned Opportunity records by any field
        distinct
            Filter Opportunity records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Opportunity
            The first Opportunity record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Opportunity record ordered by the id field
        opportunity = await Opportunity.prisma().find_first_or_raise(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.OpportunityUpdateInput,
        where: types.OpportunityWhereUniqueInput,
        include: Optional[types.OpportunityInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Opportunity record.

        Parameters
        ----------
        data
            Opportunity record data specifying what to update
        where
            Opportunity filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The updated Opportunity record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        opportunity = await Opportunity.prisma().update(
            where={
                'id': 'bcajcajjbc',
            },
            data={
                # data to update the Opportunity record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.OpportunityWhereUniqueInput,
        data: types.OpportunityUpsertInput,
        include: Optional[types.OpportunityInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Opportunity filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Opportunity model

        Returns
        -------
        prisma.models.Opportunity
            The created or updated Opportunity record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        opportunity = await Opportunity.prisma().upsert(
            where={
                'id': 'bfdgheeegf',
            },
            data={
                'create': {
                    'id': 'bfdgheeegf',
                    'name': 'daafgidjg',
                },
                'update': {
                    'name': 'daafgidjg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.OpportunityUpdateManyMutationInput,
        where: types.OpportunityWhereInput,
    ) -> int:
        """Update multiple Opportunity records

        Parameters
        ----------
        data
            Opportunity data to update the selected Opportunity records to
        where
            Filter to select the Opportunity records to update

        Returns
        -------
        int
            The total number of Opportunity records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Opportunity records
        total = await Opportunity.prisma().update_many(
            data={
                'name': 'ececbijji'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Opportunity records present in the database

        Parameters
        ----------
        select
            Select the Opportunity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Opportunity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OpportunityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Opportunity.prisma().count()

        # results: prisma.types.OpportunityCountAggregateOutput
        results = await Opportunity.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.OpportunityCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
    ) -> types.OpportunityCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.OpportunityCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.OpportunityWhereInput] = None,
        cursor: Optional[types.OpportunityWhereUniqueInput] = None,
    ) -> Union[int, types.OpportunityCountAggregateOutput]:
        """Count the number of Opportunity records present in the database

        Parameters
        ----------
        select
            Select the Opportunity fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Opportunity filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.OpportunityCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Opportunity.prisma().count()

        # results: prisma.types.OpportunityCountAggregateOutput
        results = await Opportunity.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.OpportunityCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.OpportunityWhereInput] = None
    ) -> int:
        """Delete multiple Opportunity records.

        Parameters
        ----------
        where
            Optional Opportunity filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Opportunity records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Opportunity records
        total = await Opportunity.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.OpportunityScalarFieldKeys'],
        *,
        where: Optional['types.OpportunityWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.OpportunityAvgAggregateInput'] = None,
        sum: Optional['types.OpportunitySumAggregateInput'] = None,
        min: Optional['types.OpportunityMinAggregateInput'] = None,
        max: Optional['types.OpportunityMaxAggregateInput'] = None,
        having: Optional['types.OpportunityScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.OpportunityCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.OpportunityScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.OpportunityScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.OpportunityGroupByOutput']:
        """Group Opportunity records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Opportunity fields to group records by
        where
            Opportunity filter to select records
        take
            Limit the maximum number of Opportunity records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.OpportunityGroupByOutput]
            A list of dictionaries representing the Opportunity record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Opportunity records by id values
        # and count how many records are in each group
        results = await Opportunity.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class PositionActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Position]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Position.prisma().query_raw(
            'SELECT * FROM Position WHERE id = $1',
            'cbcfgdcdhf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Position
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Position.prisma().query_first(
            'SELECT * FROM Position WHERE name = $1',
            'fdgjfbhia',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.PositionCreateInput,
        include: Optional[types.PositionInclude] = None
    ) -> _PrismaModelT:
        """Create a new Position record.

        Parameters
        ----------
        data
            Position record data
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The created Position record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Position record from just the required fields
        position = await Position.prisma().create(
            data={
                # data to create a Position record
                'id': 'jcehcdchh',
                'name': 'bgcbjdhjcc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.PositionCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Position records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Position record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Position.prisma().create_many(
            data=[
                {
                    # data to create a Position record
                    'id': 'bieiidcabj',
                    'name': 'bjcbfcieaa',
                },
                {
                    # data to create a Position record
                    'id': 'cbaaechiej',
                    'name': 'iejbeaaeg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.PositionWhereUniqueInput,
        include: Optional[types.PositionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Position record.

        Parameters
        ----------
        where
            Position filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The deleted Position record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        position = await Position.prisma().delete(
            where={
                'id': 'jcibfcbhf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.PositionWhereUniqueInput,
        include: Optional[types.PositionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Position record.

        Parameters
        ----------
        where
            Position filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The found Position record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        position = await Position.prisma().find_unique(
            where={
                'id': 'chdadcaga',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.PositionWhereUniqueInput,
        include: Optional[types.PositionInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Position record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Position filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The found Position record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        position = await Position.prisma().find_unique_or_raise(
            where={
                'id': 'jicieifbh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
        include: Optional[types.PositionInclude] = None,
        order: Optional[Union[types.PositionOrderByInput, List[types.PositionOrderByInput]]] = None,
        distinct: Optional[List[types.PositionScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Position records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Position records returned
        skip
            Ignore the first N results
        where
            Position filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Position model
        order
            Order the returned Position records by any field
        distinct
            Filter Position records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Position]
            The list of all Position records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Position records
        positions = await Position.prisma().find_many(take=10)

        # find the first 5 Position records ordered by the description field
        positions = await Position.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
        include: Optional[types.PositionInclude] = None,
        order: Optional[Union[types.PositionOrderByInput, List[types.PositionOrderByInput]]] = None,
        distinct: Optional[List[types.PositionScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Position record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Position filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Position model
        order
            Order the returned Position records by any field
        distinct
            Filter Position records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Position
            The first Position record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Position record ordered by the id field
        position = await Position.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
        include: Optional[types.PositionInclude] = None,
        order: Optional[Union[types.PositionOrderByInput, List[types.PositionOrderByInput]]] = None,
        distinct: Optional[List[types.PositionScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Position record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Position filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Position model
        order
            Order the returned Position records by any field
        distinct
            Filter Position records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Position
            The first Position record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Position record ordered by the name field
        position = await Position.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.PositionUpdateInput,
        where: types.PositionWhereUniqueInput,
        include: Optional[types.PositionInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Position record.

        Parameters
        ----------
        data
            Position record data specifying what to update
        where
            Position filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The updated Position record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        position = await Position.prisma().update(
            where={
                'id': 'fbahdheji',
            },
            data={
                # data to update the Position record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.PositionWhereUniqueInput,
        data: types.PositionUpsertInput,
        include: Optional[types.PositionInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Position filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Position model

        Returns
        -------
        prisma.models.Position
            The created or updated Position record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        position = await Position.prisma().upsert(
            where={
                'id': 'cbbheiicgh',
            },
            data={
                'create': {
                    'id': 'cbbheiicgh',
                    'name': 'iejbeaaeg',
                },
                'update': {
                    'name': 'iejbeaaeg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.PositionUpdateManyMutationInput,
        where: types.PositionWhereInput,
    ) -> int:
        """Update multiple Position records

        Parameters
        ----------
        data
            Position data to update the selected Position records to
        where
            Filter to select the Position records to update

        Returns
        -------
        int
            The total number of Position records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Position records
        total = await Position.prisma().update_many(
            data={
                'description': 'beabjeejdg'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Position records present in the database

        Parameters
        ----------
        select
            Select the Position fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Position filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PositionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Position.prisma().count()

        # results: prisma.types.PositionCountAggregateOutput
        results = await Position.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.PositionCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
    ) -> types.PositionCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.PositionCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.PositionWhereInput] = None,
        cursor: Optional[types.PositionWhereUniqueInput] = None,
    ) -> Union[int, types.PositionCountAggregateOutput]:
        """Count the number of Position records present in the database

        Parameters
        ----------
        select
            Select the Position fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Position filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.PositionCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Position.prisma().count()

        # results: prisma.types.PositionCountAggregateOutput
        results = await Position.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.PositionCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.PositionWhereInput] = None
    ) -> int:
        """Delete multiple Position records.

        Parameters
        ----------
        where
            Optional Position filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Position records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Position records
        total = await Position.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.PositionScalarFieldKeys'],
        *,
        where: Optional['types.PositionWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.PositionAvgAggregateInput'] = None,
        sum: Optional['types.PositionSumAggregateInput'] = None,
        min: Optional['types.PositionMinAggregateInput'] = None,
        max: Optional['types.PositionMaxAggregateInput'] = None,
        having: Optional['types.PositionScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.PositionCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.PositionScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.PositionScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.PositionGroupByOutput']:
        """Group Position records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Position fields to group records by
        where
            Position filter to select records
        take
            Limit the maximum number of Position records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.PositionGroupByOutput]
            A list of dictionaries representing the Position record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Position records by description values
        # and count how many records are in each group
        results = await Position.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Product]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Product.prisma().query_raw(
            'SELECT * FROM Product WHERE id = $1',
            'bcjhgahffd',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Product
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Product.prisma().query_first(
            'SELECT * FROM Product WHERE name = $1',
            'fbjeiiffa',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductCreateInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Create a new Product record.

        Parameters
        ----------
        data
            Product record data
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created Product record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Product record from just the required fields
        product = await Product.prisma().create(
            data={
                # data to create a Product record
                'id': 'jhgidcgbf',
                'name': 'bgjgecfejc',
                'quantity': 169262781,
                'prices': 1023081650,
                'updatedAt': datetime.datetime.utcnow(),
                'creatorId': 'dchgibach',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Product records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Product record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Product.prisma().create_many(
            data=[
                {
                    # data to create a Product record
                    'id': 'fchheijjc',
                    'name': 'cacjdfhejh',
                    'quantity': 1318597118,
                    'prices': 2122112351,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bacejedaca',
                },
                {
                    # data to create a Product record
                    'id': 'bhbhdahfaj',
                    'name': 'bfjibceaec',
                    'quantity': 817623163,
                    'prices': 1030557336,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bbdbfcfihd',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Product record.

        Parameters
        ----------
        where
            Product filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The deleted Product record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().delete(
            where={
                'id': 'cbagggbji',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Product record.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique(
            where={
                'id': 'bchgafhjed',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Product record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Product filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The found Product record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().find_unique_or_raise(
            where={
                'id': 'heffgjdei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Product records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N results
        where
            Product filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Product]
            The list of all Product records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Product records
        products = await Product.prisma().find_many(take=10)

        # find the first 5 Product records ordered by the description field
        products = await Product.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Product record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the volume field
        product = await Product.prisma().find_first(
            skip=1,
            order={
                'volume': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
        include: Optional[types.ProductInclude] = None,
        order: Optional[Union[types.ProductOrderByInput, List[types.ProductOrderByInput]]] = None,
        distinct: Optional[List[types.ProductScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Product record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Product filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Product model
        order
            Order the returned Product records by any field
        distinct
            Filter Product records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Product
            The first Product record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Product record ordered by the unit field
        product = await Product.prisma().find_first_or_raise(
            skip=1,
            order={
                'unit': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductUpdateInput,
        where: types.ProductWhereUniqueInput,
        include: Optional[types.ProductInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Product record.

        Parameters
        ----------
        data
            Product record data specifying what to update
        where
            Product filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The updated Product record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        product = await Product.prisma().update(
            where={
                'id': 'dahihgbeb',
            },
            data={
                # data to update the Product record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductWhereUniqueInput,
        data: types.ProductUpsertInput,
        include: Optional[types.ProductInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Product filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Product model

        Returns
        -------
        prisma.models.Product
            The created or updated Product record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        product = await Product.prisma().upsert(
            where={
                'id': 'bgheaejbcc',
            },
            data={
                'create': {
                    'id': 'bgheaejbcc',
                    'name': 'bfjibceaec',
                    'quantity': 817623163,
                    'prices': 1030557336,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bbdbfcfihd',
                },
                'update': {
                    'name': 'bfjibceaec',
                    'quantity': 817623163,
                    'prices': 1030557336,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bbdbfcfihd',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductUpdateManyMutationInput,
        where: types.ProductWhereInput,
    ) -> int:
        """Update multiple Product records

        Parameters
        ----------
        data
            Product data to update the selected Product records to
        where
            Filter to select the Product records to update

        Returns
        -------
        int
            The total number of Product records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Product records
        total = await Product.prisma().update_many(
            data={
                'quantity': 1526854643
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'prices': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> types.ProductCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductWhereInput] = None,
        cursor: Optional[types.ProductWhereUniqueInput] = None,
    ) -> Union[int, types.ProductCountAggregateOutput]:
        """Count the number of Product records present in the database

        Parameters
        ----------
        select
            Select the Product fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Product filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Product.prisma().count()

        # results: prisma.types.ProductCountAggregateOutput
        results = await Product.prisma().count(
            select={
                '_all': True,
                'createdAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductWhereInput] = None
    ) -> int:
        """Delete multiple Product records.

        Parameters
        ----------
        where
            Optional Product filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Product records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Product records
        total = await Product.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductScalarFieldKeys'],
        *,
        where: Optional['types.ProductWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductAvgAggregateInput'] = None,
        sum: Optional['types.ProductSumAggregateInput'] = None,
        min: Optional['types.ProductMinAggregateInput'] = None,
        max: Optional['types.ProductMaxAggregateInput'] = None,
        having: Optional['types.ProductScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductGroupByOutput']:
        """Group Product records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Product fields to group records by
        where
            Product filter to select records
        take
            Limit the maximum number of Product records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductGroupByOutput]
            A list of dictionaries representing the Product record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Product records by updatedAt values
        # and count how many records are in each group
        results = await Product.prisma().group_by(
            ['updatedAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ProductSaleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ProductSale]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ProductSale.prisma().query_raw(
            'SELECT * FROM ProductSale WHERE id = $1',
            'jfiahhbae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ProductSale
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ProductSale.prisma().query_first(
            'SELECT * FROM ProductSale WHERE productId = $1',
            'bfbdafajcb',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ProductSaleCreateInput,
        include: Optional[types.ProductSaleInclude] = None
    ) -> _PrismaModelT:
        """Create a new ProductSale record.

        Parameters
        ----------
        data
            ProductSale record data
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The created ProductSale record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ProductSale record from just the required fields
        productsale = await ProductSale.prisma().create(
            data={
                # data to create a ProductSale record
                'id': 'caeghehde',
                'productId': 'caghgfbggd',
                'clientId': 'bbidjbbjaa',
                'quantity': 1589704933,
                'price': 1243475898.136982,
                'totalPrice': 1678593480.40352,
                'creatorId': 'geihgahba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ProductSaleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ProductSale records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ProductSale record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ProductSale.prisma().create_many(
            data=[
                {
                    # data to create a ProductSale record
                    'id': 'gahdcdhbj',
                    'productId': 'begiijahea',
                    'clientId': 'gcjadjaaf',
                    'quantity': 1214168082,
                    'price': 898613219.65837,
                    'totalPrice': 954620057.121480,
                    'creatorId': 'baehicaajf',
                },
                {
                    # data to create a ProductSale record
                    'id': 'bdachdeiga',
                    'productId': 'ijdafccef',
                    'clientId': 'ciaaiddag',
                    'quantity': 549668955,
                    'price': 76790008.209829,
                    'totalPrice': 245900342.81186,
                    'creatorId': 'bdiiiabbii',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ProductSaleWhereUniqueInput,
        include: Optional[types.ProductSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ProductSale record.

        Parameters
        ----------
        where
            ProductSale filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The deleted ProductSale record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productsale = await ProductSale.prisma().delete(
            where={
                'id': 'hfcfhhadh',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ProductSaleWhereUniqueInput,
        include: Optional[types.ProductSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ProductSale record.

        Parameters
        ----------
        where
            ProductSale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The found ProductSale record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productsale = await ProductSale.prisma().find_unique(
            where={
                'id': 'bbihggdcji',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ProductSaleWhereUniqueInput,
        include: Optional[types.ProductSaleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ProductSale record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ProductSale filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The found ProductSale record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productsale = await ProductSale.prisma().find_unique_or_raise(
            where={
                'id': 'hgjgibdgd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
        include: Optional[types.ProductSaleInclude] = None,
        order: Optional[Union[types.ProductSaleOrderByInput, List[types.ProductSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ProductSaleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ProductSale records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ProductSale records returned
        skip
            Ignore the first N results
        where
            ProductSale filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductSale model
        order
            Order the returned ProductSale records by any field
        distinct
            Filter ProductSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ProductSale]
            The list of all ProductSale records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ProductSale records
        productsales = await ProductSale.prisma().find_many(take=10)

        # find the first 5 ProductSale records ordered by the clientId field
        productsales = await ProductSale.prisma().find_many(
            take=5,
            order={
                'clientId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
        include: Optional[types.ProductSaleInclude] = None,
        order: Optional[Union[types.ProductSaleOrderByInput, List[types.ProductSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ProductSaleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ProductSale record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProductSale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductSale model
        order
            Order the returned ProductSale records by any field
        distinct
            Filter ProductSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProductSale
            The first ProductSale record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProductSale record ordered by the quantity field
        productsale = await ProductSale.prisma().find_first(
            skip=1,
            order={
                'quantity': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
        include: Optional[types.ProductSaleInclude] = None,
        order: Optional[Union[types.ProductSaleOrderByInput, List[types.ProductSaleOrderByInput]]] = None,
        distinct: Optional[List[types.ProductSaleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ProductSale record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ProductSale filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ProductSale model
        order
            Order the returned ProductSale records by any field
        distinct
            Filter ProductSale records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ProductSale
            The first ProductSale record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ProductSale record ordered by the price field
        productsale = await ProductSale.prisma().find_first_or_raise(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ProductSaleUpdateInput,
        where: types.ProductSaleWhereUniqueInput,
        include: Optional[types.ProductSaleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ProductSale record.

        Parameters
        ----------
        data
            ProductSale record data specifying what to update
        where
            ProductSale filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The updated ProductSale record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        productsale = await ProductSale.prisma().update(
            where={
                'id': 'bcbecjfice',
            },
            data={
                # data to update the ProductSale record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ProductSaleWhereUniqueInput,
        data: types.ProductSaleUpsertInput,
        include: Optional[types.ProductSaleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ProductSale filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ProductSale model

        Returns
        -------
        prisma.models.ProductSale
            The created or updated ProductSale record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        productsale = await ProductSale.prisma().upsert(
            where={
                'id': 'bacbebhjjd',
            },
            data={
                'create': {
                    'id': 'bacbebhjjd',
                    'productId': 'ijdafccef',
                    'clientId': 'ciaaiddag',
                    'quantity': 549668955,
                    'price': 76790008.209829,
                    'totalPrice': 245900342.81186,
                    'creatorId': 'bdiiiabbii',
                },
                'update': {
                    'productId': 'ijdafccef',
                    'clientId': 'ciaaiddag',
                    'quantity': 549668955,
                    'price': 76790008.209829,
                    'totalPrice': 245900342.81186,
                    'creatorId': 'bdiiiabbii',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ProductSaleUpdateManyMutationInput,
        where: types.ProductSaleWhereInput,
    ) -> int:
        """Update multiple ProductSale records

        Parameters
        ----------
        data
            ProductSale data to update the selected ProductSale records to
        where
            Filter to select the ProductSale records to update

        Returns
        -------
        int
            The total number of ProductSale records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ProductSale records
        total = await ProductSale.prisma().update_many(
            data={
                'totalPrice': 351503374.132118
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ProductSale records present in the database

        Parameters
        ----------
        select
            Select the ProductSale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProductSale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductSaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProductSale.prisma().count()

        # results: prisma.types.ProductSaleCountAggregateOutput
        results = await ProductSale.prisma().count(
            select={
                '_all': True,
                'saleDate': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ProductSaleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
    ) -> types.ProductSaleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ProductSaleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ProductSaleWhereInput] = None,
        cursor: Optional[types.ProductSaleWhereUniqueInput] = None,
    ) -> Union[int, types.ProductSaleCountAggregateOutput]:
        """Count the number of ProductSale records present in the database

        Parameters
        ----------
        select
            Select the ProductSale fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ProductSale filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ProductSaleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ProductSale.prisma().count()

        # results: prisma.types.ProductSaleCountAggregateOutput
        results = await ProductSale.prisma().count(
            select={
                '_all': True,
                'creatorId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ProductSaleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ProductSaleWhereInput] = None
    ) -> int:
        """Delete multiple ProductSale records.

        Parameters
        ----------
        where
            Optional ProductSale filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ProductSale records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ProductSale records
        total = await ProductSale.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ProductSaleScalarFieldKeys'],
        *,
        where: Optional['types.ProductSaleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ProductSaleAvgAggregateInput'] = None,
        sum: Optional['types.ProductSaleSumAggregateInput'] = None,
        min: Optional['types.ProductSaleMinAggregateInput'] = None,
        max: Optional['types.ProductSaleMaxAggregateInput'] = None,
        having: Optional['types.ProductSaleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ProductSaleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ProductSaleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ProductSaleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ProductSaleGroupByOutput']:
        """Group ProductSale records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ProductSale fields to group records by
        where
            ProductSale filter to select records
        take
            Limit the maximum number of ProductSale records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ProductSaleGroupByOutput]
            A list of dictionaries representing the ProductSale record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ProductSale records by id values
        # and count how many records are in each group
        results = await ProductSale.prisma().group_by(
            ['id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ReviewActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Review]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Review.prisma().query_raw(
            'SELECT * FROM Review WHERE id = $1',
            'dgjhdcggi',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Review
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Review.prisma().query_first(
            'SELECT * FROM Review WHERE serviceId = $1',
            'bbjbcdfabd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ReviewCreateInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Create a new Review record.

        Parameters
        ----------
        data
            Review record data
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created Review record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Review record from just the required fields
        review = await Review.prisma().create(
            data={
                # data to create a Review record
                'id': 'gchfgbcec',
                'serviceId': 'bihcjfcjah',
                'clientId': 'bhjdcicaii',
                'grade': enums.EGrade.VERY_BAD,
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ReviewCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Review records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Review record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Review.prisma().create_many(
            data=[
                {
                    # data to create a Review record
                    'id': 'bibedjhcej',
                    'serviceId': 'bjcdajabfa',
                    'clientId': 'bchhceeeff',
                    'grade': enums.EGrade.VERY_BAD,
                },
                {
                    # data to create a Review record
                    'id': 'bbgaifhdaa',
                    'serviceId': 'dgbcdaegb',
                    'clientId': 'beagfbbjig',
                    'grade': enums.EGrade.VERY_BAD,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Review record.

        Parameters
        ----------
        where
            Review filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The deleted Review record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().delete(
            where={
                'id': 'beicihhijb',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Review record.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique(
            where={
                'id': 'fgggcdcjg',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Review record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Review filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The found Review record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().find_unique_or_raise(
            where={
                'id': 'ccjbbjigf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Review records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N results
        where
            Review filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Review]
            The list of all Review records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Review records
        reviews = await Review.prisma().find_many(take=10)

        # find the first 5 Review records ordered by the clientId field
        reviews = await Review.prisma().find_many(
            take=5,
            order={
                'clientId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Review record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the comment field
        review = await Review.prisma().find_first(
            skip=1,
            order={
                'comment': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
        include: Optional[types.ReviewInclude] = None,
        order: Optional[Union[types.ReviewOrderByInput, List[types.ReviewOrderByInput]]] = None,
        distinct: Optional[List[types.ReviewScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Review record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Review filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Review model
        order
            Order the returned Review records by any field
        distinct
            Filter Review records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Review
            The first Review record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Review record ordered by the grade field
        review = await Review.prisma().find_first_or_raise(
            skip=1,
            order={
                'grade': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ReviewUpdateInput,
        where: types.ReviewWhereUniqueInput,
        include: Optional[types.ReviewInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Review record.

        Parameters
        ----------
        data
            Review record data specifying what to update
        where
            Review filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The updated Review record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        review = await Review.prisma().update(
            where={
                'id': 'bhfaabbaha',
            },
            data={
                # data to update the Review record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ReviewWhereUniqueInput,
        data: types.ReviewUpsertInput,
        include: Optional[types.ReviewInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Review filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Review model

        Returns
        -------
        prisma.models.Review
            The created or updated Review record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        review = await Review.prisma().upsert(
            where={
                'id': 'ebajedhhf',
            },
            data={
                'create': {
                    'id': 'ebajedhhf',
                    'serviceId': 'dgbcdaegb',
                    'clientId': 'beagfbbjig',
                    'grade': enums.EGrade.VERY_BAD,
                },
                'update': {
                    'serviceId': 'dgbcdaegb',
                    'clientId': 'beagfbbjig',
                    'grade': enums.EGrade.VERY_BAD,
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ReviewUpdateManyMutationInput,
        where: types.ReviewWhereInput,
    ) -> int:
        """Update multiple Review records

        Parameters
        ----------
        data
            Review data to update the selected Review records to
        where
            Filter to select the Review records to update

        Returns
        -------
        int
            The total number of Review records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Review records
        total = await Review.prisma().update_many(
            data={
                'id': 'jajacedge'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'serviceId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ReviewCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> types.ReviewCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ReviewCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ReviewWhereInput] = None,
        cursor: Optional[types.ReviewWhereUniqueInput] = None,
    ) -> Union[int, types.ReviewCountAggregateOutput]:
        """Count the number of Review records present in the database

        Parameters
        ----------
        select
            Select the Review fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Review filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ReviewCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Review.prisma().count()

        # results: prisma.types.ReviewCountAggregateOutput
        results = await Review.prisma().count(
            select={
                '_all': True,
                'clientId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ReviewCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ReviewWhereInput] = None
    ) -> int:
        """Delete multiple Review records.

        Parameters
        ----------
        where
            Optional Review filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Review records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Review records
        total = await Review.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ReviewScalarFieldKeys'],
        *,
        where: Optional['types.ReviewWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ReviewAvgAggregateInput'] = None,
        sum: Optional['types.ReviewSumAggregateInput'] = None,
        min: Optional['types.ReviewMinAggregateInput'] = None,
        max: Optional['types.ReviewMaxAggregateInput'] = None,
        having: Optional['types.ReviewScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ReviewCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ReviewScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ReviewGroupByOutput']:
        """Group Review records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Review fields to group records by
        where
            Review filter to select records
        take
            Limit the maximum number of Review records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ReviewGroupByOutput]
            A list of dictionaries representing the Review record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Review records by comment values
        # and count how many records are in each group
        results = await Review.prisma().group_by(
            ['comment'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class RoleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Role]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Role.prisma().query_raw(
            'SELECT * FROM Role WHERE id = $1',
            'hffgbabgf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Role
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Role.prisma().query_first(
            'SELECT * FROM Role WHERE name = $1',
            'biacbiieja',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.RoleCreateInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Role record.

        Parameters
        ----------
        data
            Role record data
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created Role record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Role record from just the required fields
        role = await Role.prisma().create(
            data={
                # data to create a Role record
                'id': 'cjejbgbff',
                'name': 'fgeahddae',
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.RoleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Role records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Role record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Role.prisma().create_many(
            data=[
                {
                    # data to create a Role record
                    'id': 'diageigcf',
                    'name': 'badagbgeha',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a Role record
                    'id': 'ibgebbjch',
                    'name': 'baieajjiee',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Role record.

        Parameters
        ----------
        where
            Role filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The deleted Role record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().delete(
            where={
                'id': 'bahjhaccfd',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Role record.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().find_unique(
            where={
                'id': 'hffhfabhi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Role record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Role filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The found Role record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().find_unique_or_raise(
            where={
                'id': 'bbcigiadhb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Role records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N results
        where
            Role filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Role]
            The list of all Role records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Role records
        roles = await Role.prisma().find_many(take=10)

        # find the first 5 Role records ordered by the createdAt field
        roles = await Role.prisma().find_many(
            take=5,
            order={
                'createdAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Role record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the deletedAt field
        role = await Role.prisma().find_first(
            skip=1,
            order={
                'deletedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
        include: Optional[types.RoleInclude] = None,
        order: Optional[Union[types.RoleOrderByInput, List[types.RoleOrderByInput]]] = None,
        distinct: Optional[List[types.RoleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Role record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Role filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Role model
        order
            Order the returned Role records by any field
        distinct
            Filter Role records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Role
            The first Role record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Role record ordered by the updatedAt field
        role = await Role.prisma().find_first_or_raise(
            skip=1,
            order={
                'updatedAt': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.RoleUpdateInput,
        where: types.RoleWhereUniqueInput,
        include: Optional[types.RoleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Role record.

        Parameters
        ----------
        data
            Role record data specifying what to update
        where
            Role filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The updated Role record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        role = await Role.prisma().update(
            where={
                'id': 'cfjagbbae',
            },
            data={
                # data to update the Role record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.RoleWhereUniqueInput,
        data: types.RoleUpsertInput,
        include: Optional[types.RoleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Role filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Role model

        Returns
        -------
        prisma.models.Role
            The created or updated Role record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        role = await Role.prisma().upsert(
            where={
                'id': 'bbbfhdidef',
            },
            data={
                'create': {
                    'id': 'bbbfhdidef',
                    'name': 'baieajjiee',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'name': 'baieajjiee',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.RoleUpdateManyMutationInput,
        where: types.RoleWhereInput,
    ) -> int:
        """Update multiple Role records

        Parameters
        ----------
        data
            Role data to update the selected Role records to
        where
            Filter to select the Role records to update

        Returns
        -------
        int
            The total number of Role records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Role records
        total = await Role.prisma().update_many(
            data={
                'description': 'bdadhibhec'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = await Role.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.RoleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> types.RoleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.RoleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.RoleWhereInput] = None,
        cursor: Optional[types.RoleWhereUniqueInput] = None,
    ) -> Union[int, types.RoleCountAggregateOutput]:
        """Count the number of Role records present in the database

        Parameters
        ----------
        select
            Select the Role fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Role filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.RoleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Role.prisma().count()

        # results: prisma.types.RoleCountAggregateOutput
        results = await Role.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.RoleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.RoleWhereInput] = None
    ) -> int:
        """Delete multiple Role records.

        Parameters
        ----------
        where
            Optional Role filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Role records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Role records
        total = await Role.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.RoleScalarFieldKeys'],
        *,
        where: Optional['types.RoleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.RoleAvgAggregateInput'] = None,
        sum: Optional['types.RoleSumAggregateInput'] = None,
        min: Optional['types.RoleMinAggregateInput'] = None,
        max: Optional['types.RoleMaxAggregateInput'] = None,
        having: Optional['types.RoleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.RoleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.RoleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.RoleGroupByOutput']:
        """Group Role records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Role fields to group records by
        where
            Role filter to select records
        take
            Limit the maximum number of Role records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.RoleGroupByOutput]
            A list of dictionaries representing the Role record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Role records by createdAt values
        # and count how many records are in each group
        results = await Role.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ScheduleActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Schedule]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Schedule.prisma().query_raw(
            'SELECT * FROM Schedule WHERE id = $1',
            'bfhdjaiejf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Schedule
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Schedule.prisma().query_first(
            'SELECT * FROM Schedule WHERE date = $1',
            datetime.datetime.utcnow(),
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ScheduleCreateInput,
        include: Optional[types.ScheduleInclude] = None
    ) -> _PrismaModelT:
        """Create a new Schedule record.

        Parameters
        ----------
        data
            Schedule record data
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The created Schedule record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Schedule record from just the required fields
        schedule = await Schedule.prisma().create(
            data={
                # data to create a Schedule record
                'id': 'bbjfijjadg',
                'date': datetime.datetime.utcnow(),
                'startTime': datetime.datetime.utcnow(),
                'endTime': datetime.datetime.utcnow(),
                'userId': 'hdjacbehh',
                'cabinetId': 'bhcccbeaba',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ScheduleCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Schedule records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Schedule record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Schedule.prisma().create_many(
            data=[
                {
                    # data to create a Schedule record
                    'id': 'bcgjbdgjdj',
                    'date': datetime.datetime.utcnow(),
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                    'userId': 'fhdbhifae',
                    'cabinetId': 'beeacgfcej',
                },
                {
                    # data to create a Schedule record
                    'id': 'bbifhdiicc',
                    'date': datetime.datetime.utcnow(),
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                    'userId': 'bgjeccejad',
                    'cabinetId': 'bjagdgabbg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ScheduleWhereUniqueInput,
        include: Optional[types.ScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Schedule record.

        Parameters
        ----------
        where
            Schedule filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The deleted Schedule record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        schedule = await Schedule.prisma().delete(
            where={
                'id': 'bjbbcffdij',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ScheduleWhereUniqueInput,
        include: Optional[types.ScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Schedule record.

        Parameters
        ----------
        where
            Schedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The found Schedule record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        schedule = await Schedule.prisma().find_unique(
            where={
                'id': 'begcgchdi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ScheduleWhereUniqueInput,
        include: Optional[types.ScheduleInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Schedule record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Schedule filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The found Schedule record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        schedule = await Schedule.prisma().find_unique_or_raise(
            where={
                'id': 'bhbjceagbb',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
        include: Optional[types.ScheduleInclude] = None,
        order: Optional[Union[types.ScheduleOrderByInput, List[types.ScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.ScheduleScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Schedule records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Schedule records returned
        skip
            Ignore the first N results
        where
            Schedule filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Schedule model
        order
            Order the returned Schedule records by any field
        distinct
            Filter Schedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Schedule]
            The list of all Schedule records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Schedule records
        schedules = await Schedule.prisma().find_many(take=10)

        # find the first 5 Schedule records ordered by the startTime field
        schedules = await Schedule.prisma().find_many(
            take=5,
            order={
                'startTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
        include: Optional[types.ScheduleInclude] = None,
        order: Optional[Union[types.ScheduleOrderByInput, List[types.ScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.ScheduleScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Schedule record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Schedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Schedule model
        order
            Order the returned Schedule records by any field
        distinct
            Filter Schedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Schedule
            The first Schedule record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Schedule record ordered by the endTime field
        schedule = await Schedule.prisma().find_first(
            skip=1,
            order={
                'endTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
        include: Optional[types.ScheduleInclude] = None,
        order: Optional[Union[types.ScheduleOrderByInput, List[types.ScheduleOrderByInput]]] = None,
        distinct: Optional[List[types.ScheduleScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Schedule record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Schedule filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Schedule model
        order
            Order the returned Schedule records by any field
        distinct
            Filter Schedule records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Schedule
            The first Schedule record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Schedule record ordered by the userId field
        schedule = await Schedule.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ScheduleUpdateInput,
        where: types.ScheduleWhereUniqueInput,
        include: Optional[types.ScheduleInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Schedule record.

        Parameters
        ----------
        data
            Schedule record data specifying what to update
        where
            Schedule filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The updated Schedule record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        schedule = await Schedule.prisma().update(
            where={
                'id': 'bjeifffjdg',
            },
            data={
                # data to update the Schedule record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ScheduleWhereUniqueInput,
        data: types.ScheduleUpsertInput,
        include: Optional[types.ScheduleInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Schedule filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Schedule model

        Returns
        -------
        prisma.models.Schedule
            The created or updated Schedule record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        schedule = await Schedule.prisma().upsert(
            where={
                'id': 'bdidcfdfjd',
            },
            data={
                'create': {
                    'id': 'bdidcfdfjd',
                    'date': datetime.datetime.utcnow(),
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                    'userId': 'bgjeccejad',
                    'cabinetId': 'bjagdgabbg',
                },
                'update': {
                    'date': datetime.datetime.utcnow(),
                    'startTime': datetime.datetime.utcnow(),
                    'endTime': datetime.datetime.utcnow(),
                    'userId': 'bgjeccejad',
                    'cabinetId': 'bjagdgabbg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ScheduleUpdateManyMutationInput,
        where: types.ScheduleWhereInput,
    ) -> int:
        """Update multiple Schedule records

        Parameters
        ----------
        data
            Schedule data to update the selected Schedule records to
        where
            Filter to select the Schedule records to update

        Returns
        -------
        int
            The total number of Schedule records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Schedule records
        total = await Schedule.prisma().update_many(
            data={
                'cabinetId': 'dfeggejja'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Schedule records present in the database

        Parameters
        ----------
        select
            Select the Schedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Schedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Schedule.prisma().count()

        # results: prisma.types.ScheduleCountAggregateOutput
        results = await Schedule.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ScheduleCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
    ) -> types.ScheduleCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ScheduleCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ScheduleWhereInput] = None,
        cursor: Optional[types.ScheduleWhereUniqueInput] = None,
    ) -> Union[int, types.ScheduleCountAggregateOutput]:
        """Count the number of Schedule records present in the database

        Parameters
        ----------
        select
            Select the Schedule fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Schedule filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ScheduleCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Schedule.prisma().count()

        # results: prisma.types.ScheduleCountAggregateOutput
        results = await Schedule.prisma().count(
            select={
                '_all': True,
                'date': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ScheduleCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ScheduleWhereInput] = None
    ) -> int:
        """Delete multiple Schedule records.

        Parameters
        ----------
        where
            Optional Schedule filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Schedule records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Schedule records
        total = await Schedule.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ScheduleScalarFieldKeys'],
        *,
        where: Optional['types.ScheduleWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ScheduleAvgAggregateInput'] = None,
        sum: Optional['types.ScheduleSumAggregateInput'] = None,
        min: Optional['types.ScheduleMinAggregateInput'] = None,
        max: Optional['types.ScheduleMaxAggregateInput'] = None,
        having: Optional['types.ScheduleScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ScheduleCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ScheduleScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ScheduleScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ScheduleGroupByOutput']:
        """Group Schedule records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Schedule fields to group records by
        where
            Schedule filter to select records
        take
            Limit the maximum number of Schedule records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ScheduleGroupByOutput]
            A list of dictionaries representing the Schedule record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Schedule records by startTime values
        # and count how many records are in each group
        results = await Schedule.prisma().group_by(
            ['startTime'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ServiceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.Service]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await Service.prisma().query_raw(
            'SELECT * FROM Service WHERE id = $1',
            'gehbgghbj',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.Service
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await Service.prisma().query_first(
            'SELECT * FROM Service WHERE name = $1',
            'dfhaijeie',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ServiceCreateInput,
        include: Optional[types.ServiceInclude] = None
    ) -> _PrismaModelT:
        """Create a new Service record.

        Parameters
        ----------
        data
            Service record data
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The created Service record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a Service record from just the required fields
        service = await Service.prisma().create(
            data={
                # data to create a Service record
                'id': 'gbcdjgicb',
                'name': 'biaibdagac',
                'price': 1151748123,
                'duration': 78060984.44498,
                'updatedAt': datetime.datetime.utcnow(),
                'creatorId': 'efgbahec',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ServiceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple Service records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of Service record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await Service.prisma().create_many(
            data=[
                {
                    # data to create a Service record
                    'id': 'hgjaiebfb',
                    'name': 'bddefjjabc',
                    'price': 1116761037,
                    'duration': 1172606082.33001,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bhgibfgbbc',
                },
                {
                    # data to create a Service record
                    'id': 'hbgcihef',
                    'name': 'ffhgghde',
                    'price': 812032495,
                    'duration': 1323562236.4379,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bdeffdadda',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ServiceWhereUniqueInput,
        include: Optional[types.ServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single Service record.

        Parameters
        ----------
        where
            Service filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The deleted Service record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        service = await Service.prisma().delete(
            where={
                'id': 'bjgfdihchf',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ServiceWhereUniqueInput,
        include: Optional[types.ServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique Service record.

        Parameters
        ----------
        where
            Service filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The found Service record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        service = await Service.prisma().find_unique(
            where={
                'id': 'iaeihdeei',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ServiceWhereUniqueInput,
        include: Optional[types.ServiceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique Service record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            Service filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The found Service record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        service = await Service.prisma().find_unique_or_raise(
            where={
                'id': 'bfggejgfbd',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
        include: Optional[types.ServiceInclude] = None,
        order: Optional[Union[types.ServiceOrderByInput, List[types.ServiceOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple Service records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of Service records returned
        skip
            Ignore the first N results
        where
            Service filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Service model
        order
            Order the returned Service records by any field
        distinct
            Filter Service records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.Service]
            The list of all Service records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 Service records
        services = await Service.prisma().find_many(take=10)

        # find the first 5 Service records ordered by the description field
        services = await Service.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
        include: Optional[types.ServiceInclude] = None,
        order: Optional[Union[types.ServiceOrderByInput, List[types.ServiceOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single Service record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Service filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Service model
        order
            Order the returned Service records by any field
        distinct
            Filter Service records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Service
            The first Service record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Service record ordered by the price field
        service = await Service.prisma().find_first(
            skip=1,
            order={
                'price': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
        include: Optional[types.ServiceInclude] = None,
        order: Optional[Union[types.ServiceOrderByInput, List[types.ServiceOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single Service record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            Service filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned Service model
        order
            Order the returned Service records by any field
        distinct
            Filter Service records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.Service
            The first Service record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second Service record ordered by the duration field
        service = await Service.prisma().find_first_or_raise(
            skip=1,
            order={
                'duration': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ServiceUpdateInput,
        where: types.ServiceWhereUniqueInput,
        include: Optional[types.ServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single Service record.

        Parameters
        ----------
        data
            Service record data specifying what to update
        where
            Service filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The updated Service record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        service = await Service.prisma().update(
            where={
                'id': 'ifaaaedja',
            },
            data={
                # data to update the Service record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ServiceWhereUniqueInput,
        data: types.ServiceUpsertInput,
        include: Optional[types.ServiceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            Service filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned Service model

        Returns
        -------
        prisma.models.Service
            The created or updated Service record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        service = await Service.prisma().upsert(
            where={
                'id': 'cbajdjjabf',
            },
            data={
                'create': {
                    'id': 'cbajdjjabf',
                    'name': 'ffhgghde',
                    'price': 812032495,
                    'duration': 1323562236.4379,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bdeffdadda',
                },
                'update': {
                    'name': 'ffhgghde',
                    'price': 812032495,
                    'duration': 1323562236.4379,
                    'updatedAt': datetime.datetime.utcnow(),
                    'creatorId': 'bdeffdadda',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ServiceUpdateManyMutationInput,
        where: types.ServiceWhereInput,
    ) -> int:
        """Update multiple Service records

        Parameters
        ----------
        data
            Service data to update the selected Service records to
        where
            Filter to select the Service records to update

        Returns
        -------
        int
            The total number of Service records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all Service records
        total = await Service.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of Service records present in the database

        Parameters
        ----------
        select
            Select the Service fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Service filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Service.prisma().count()

        # results: prisma.types.ServiceCountAggregateOutput
        results = await Service.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ServiceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
    ) -> types.ServiceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ServiceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceWhereInput] = None,
        cursor: Optional[types.ServiceWhereUniqueInput] = None,
    ) -> Union[int, types.ServiceCountAggregateOutput]:
        """Count the number of Service records present in the database

        Parameters
        ----------
        select
            Select the Service fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            Service filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await Service.prisma().count()

        # results: prisma.types.ServiceCountAggregateOutput
        results = await Service.prisma().count(
            select={
                '_all': True,
                'deletedAt': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ServiceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ServiceWhereInput] = None
    ) -> int:
        """Delete multiple Service records.

        Parameters
        ----------
        where
            Optional Service filter to find the records to be deleted

        Returns
        -------
        int
            The total number of Service records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all Service records
        total = await Service.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ServiceScalarFieldKeys'],
        *,
        where: Optional['types.ServiceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ServiceAvgAggregateInput'] = None,
        sum: Optional['types.ServiceSumAggregateInput'] = None,
        min: Optional['types.ServiceMinAggregateInput'] = None,
        max: Optional['types.ServiceMaxAggregateInput'] = None,
        having: Optional['types.ServiceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ServiceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ServiceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ServiceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ServiceGroupByOutput']:
        """Group Service records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar Service fields to group records by
        where
            Service filter to select records
        take
            Limit the maximum number of Service records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ServiceGroupByOutput]
            A list of dictionaries representing the Service record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group Service records by creatorId values
        # and count how many records are in each group
        results = await Service.prisma().group_by(
            ['creatorId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ServiceCategoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ServiceCategory]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ServiceCategory.prisma().query_raw(
            'SELECT * FROM ServiceCategory WHERE id = $1',
            'bcicggedea',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ServiceCategory
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ServiceCategory.prisma().query_first(
            'SELECT * FROM ServiceCategory WHERE name = $1',
            'cebcdadjh',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ServiceCategoryCreateInput,
        include: Optional[types.ServiceCategoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new ServiceCategory record.

        Parameters
        ----------
        data
            ServiceCategory record data
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The created ServiceCategory record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ServiceCategory record from just the required fields
        servicecategory = await ServiceCategory.prisma().create(
            data={
                # data to create a ServiceCategory record
                'id': 'ehfigdgac',
                'name': 'bhbgccijjf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ServiceCategoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ServiceCategory records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ServiceCategory record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ServiceCategory.prisma().create_many(
            data=[
                {
                    # data to create a ServiceCategory record
                    'id': 'bigjhdgbjc',
                    'name': 'bfifdebhfd',
                },
                {
                    # data to create a ServiceCategory record
                    'id': 'cjchbjde',
                    'name': 'bfiibjcehj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ServiceCategoryWhereUniqueInput,
        include: Optional[types.ServiceCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ServiceCategory record.

        Parameters
        ----------
        where
            ServiceCategory filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The deleted ServiceCategory record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicecategory = await ServiceCategory.prisma().delete(
            where={
                'id': 'ijieafghg',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ServiceCategoryWhereUniqueInput,
        include: Optional[types.ServiceCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ServiceCategory record.

        Parameters
        ----------
        where
            ServiceCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The found ServiceCategory record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicecategory = await ServiceCategory.prisma().find_unique(
            where={
                'id': 'hhhegahcf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ServiceCategoryWhereUniqueInput,
        include: Optional[types.ServiceCategoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ServiceCategory record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ServiceCategory filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The found ServiceCategory record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicecategory = await ServiceCategory.prisma().find_unique_or_raise(
            where={
                'id': 'edhijefdi',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
        include: Optional[types.ServiceCategoryInclude] = None,
        order: Optional[Union[types.ServiceCategoryOrderByInput, List[types.ServiceCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceCategoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ServiceCategory records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ServiceCategory records returned
        skip
            Ignore the first N results
        where
            ServiceCategory filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceCategory model
        order
            Order the returned ServiceCategory records by any field
        distinct
            Filter ServiceCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ServiceCategory]
            The list of all ServiceCategory records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ServiceCategory records
        servicecategorys = await ServiceCategory.prisma().find_many(take=10)

        # find the first 5 ServiceCategory records ordered by the description field
        servicecategorys = await ServiceCategory.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
        include: Optional[types.ServiceCategoryInclude] = None,
        order: Optional[Union[types.ServiceCategoryOrderByInput, List[types.ServiceCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceCategoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ServiceCategory record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ServiceCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceCategory model
        order
            Order the returned ServiceCategory records by any field
        distinct
            Filter ServiceCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ServiceCategory
            The first ServiceCategory record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ServiceCategory record ordered by the id field
        servicecategory = await ServiceCategory.prisma().find_first(
            skip=1,
            order={
                'id': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
        include: Optional[types.ServiceCategoryInclude] = None,
        order: Optional[Union[types.ServiceCategoryOrderByInput, List[types.ServiceCategoryOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceCategoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ServiceCategory record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ServiceCategory filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceCategory model
        order
            Order the returned ServiceCategory records by any field
        distinct
            Filter ServiceCategory records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ServiceCategory
            The first ServiceCategory record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ServiceCategory record ordered by the name field
        servicecategory = await ServiceCategory.prisma().find_first_or_raise(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ServiceCategoryUpdateInput,
        where: types.ServiceCategoryWhereUniqueInput,
        include: Optional[types.ServiceCategoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ServiceCategory record.

        Parameters
        ----------
        data
            ServiceCategory record data specifying what to update
        where
            ServiceCategory filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The updated ServiceCategory record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        servicecategory = await ServiceCategory.prisma().update(
            where={
                'id': 'djddecjhb',
            },
            data={
                # data to update the ServiceCategory record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ServiceCategoryWhereUniqueInput,
        data: types.ServiceCategoryUpsertInput,
        include: Optional[types.ServiceCategoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ServiceCategory filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ServiceCategory model

        Returns
        -------
        prisma.models.ServiceCategory
            The created or updated ServiceCategory record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicecategory = await ServiceCategory.prisma().upsert(
            where={
                'id': 'bgdicjhie',
            },
            data={
                'create': {
                    'id': 'bgdicjhie',
                    'name': 'bfiibjcehj',
                },
                'update': {
                    'name': 'bfiibjcehj',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ServiceCategoryUpdateManyMutationInput,
        where: types.ServiceCategoryWhereInput,
    ) -> int:
        """Update multiple ServiceCategory records

        Parameters
        ----------
        data
            ServiceCategory data to update the selected ServiceCategory records to
        where
            Filter to select the ServiceCategory records to update

        Returns
        -------
        int
            The total number of ServiceCategory records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ServiceCategory records
        total = await ServiceCategory.prisma().update_many(
            data={
                'description': 'ceibfcgij'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ServiceCategory records present in the database

        Parameters
        ----------
        select
            Select the ServiceCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ServiceCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ServiceCategory.prisma().count()

        # results: prisma.types.ServiceCategoryCountAggregateOutput
        results = await ServiceCategory.prisma().count(
            select={
                '_all': True,
                'id': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ServiceCategoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
    ) -> types.ServiceCategoryCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ServiceCategoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceCategoryWhereInput] = None,
        cursor: Optional[types.ServiceCategoryWhereUniqueInput] = None,
    ) -> Union[int, types.ServiceCategoryCountAggregateOutput]:
        """Count the number of ServiceCategory records present in the database

        Parameters
        ----------
        select
            Select the ServiceCategory fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ServiceCategory filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceCategoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ServiceCategory.prisma().count()

        # results: prisma.types.ServiceCategoryCountAggregateOutput
        results = await ServiceCategory.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ServiceCategoryCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ServiceCategoryWhereInput] = None
    ) -> int:
        """Delete multiple ServiceCategory records.

        Parameters
        ----------
        where
            Optional ServiceCategory filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ServiceCategory records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ServiceCategory records
        total = await ServiceCategory.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ServiceCategoryScalarFieldKeys'],
        *,
        where: Optional['types.ServiceCategoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ServiceCategoryAvgAggregateInput'] = None,
        sum: Optional['types.ServiceCategorySumAggregateInput'] = None,
        min: Optional['types.ServiceCategoryMinAggregateInput'] = None,
        max: Optional['types.ServiceCategoryMaxAggregateInput'] = None,
        having: Optional['types.ServiceCategoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ServiceCategoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ServiceCategoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ServiceCategoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ServiceCategoryGroupByOutput']:
        """Group ServiceCategory records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ServiceCategory fields to group records by
        where
            ServiceCategory filter to select records
        take
            Limit the maximum number of ServiceCategory records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ServiceCategoryGroupByOutput]
            A list of dictionaries representing the ServiceCategory record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ServiceCategory records by description values
        # and count how many records are in each group
        results = await ServiceCategory.prisma().group_by(
            ['description'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class ServiceRecordActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.ServiceRecord]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await ServiceRecord.prisma().query_raw(
            'SELECT * FROM ServiceRecord WHERE id = $1',
            'debhbfada',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.ServiceRecord
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await ServiceRecord.prisma().query_first(
            'SELECT * FROM ServiceRecord WHERE clientId = $1',
            'bgjchggecd',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.ServiceRecordCreateInput,
        include: Optional[types.ServiceRecordInclude] = None
    ) -> _PrismaModelT:
        """Create a new ServiceRecord record.

        Parameters
        ----------
        data
            ServiceRecord record data
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The created ServiceRecord record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a ServiceRecord record from just the required fields
        servicerecord = await ServiceRecord.prisma().create(
            data={
                # data to create a ServiceRecord record
                'id': 'igggcfjg',
                'clientId': 'bgjhijffjh',
                'workerId': 'bcigdhache',
                'dateTime': datetime.datetime.utcnow(),
                'serviceId': 'igefhgdhb',
                'officeId': 'ejbiifbae',
                'workCabinetId': 'djcfgedjd',
                'updatedAt': datetime.datetime.utcnow(),
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.ServiceRecordCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple ServiceRecord records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of ServiceRecord record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await ServiceRecord.prisma().create_many(
            data=[
                {
                    # data to create a ServiceRecord record
                    'id': 'bdbjcdegag',
                    'clientId': 'hbchfebch',
                    'workerId': 'bcjjffegfc',
                    'dateTime': datetime.datetime.utcnow(),
                    'serviceId': 'cahaeaicjd',
                    'officeId': 'ibbjaacbi',
                    'workCabinetId': 'djgacbcch',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                {
                    # data to create a ServiceRecord record
                    'id': 'geeeegace',
                    'clientId': 'bbgdigchd',
                    'workerId': 'dajcifgdi',
                    'dateTime': datetime.datetime.utcnow(),
                    'serviceId': 'ccedhdbj',
                    'officeId': 'bjaabjjjce',
                    'workCabinetId': 'cafhdcdcjd',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.ServiceRecordWhereUniqueInput,
        include: Optional[types.ServiceRecordInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single ServiceRecord record.

        Parameters
        ----------
        where
            ServiceRecord filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The deleted ServiceRecord record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicerecord = await ServiceRecord.prisma().delete(
            where={
                'id': 'bdeebbhbdi',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.ServiceRecordWhereUniqueInput,
        include: Optional[types.ServiceRecordInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique ServiceRecord record.

        Parameters
        ----------
        where
            ServiceRecord filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The found ServiceRecord record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicerecord = await ServiceRecord.prisma().find_unique(
            where={
                'id': 'cafcbdchah',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.ServiceRecordWhereUniqueInput,
        include: Optional[types.ServiceRecordInclude] = None
    ) -> _PrismaModelT:
        """Find a unique ServiceRecord record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            ServiceRecord filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The found ServiceRecord record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicerecord = await ServiceRecord.prisma().find_unique_or_raise(
            where={
                'id': 'bdffbehbae',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
        include: Optional[types.ServiceRecordInclude] = None,
        order: Optional[Union[types.ServiceRecordOrderByInput, List[types.ServiceRecordOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceRecordScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple ServiceRecord records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of ServiceRecord records returned
        skip
            Ignore the first N results
        where
            ServiceRecord filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceRecord model
        order
            Order the returned ServiceRecord records by any field
        distinct
            Filter ServiceRecord records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.ServiceRecord]
            The list of all ServiceRecord records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 ServiceRecord records
        servicerecords = await ServiceRecord.prisma().find_many(take=10)

        # find the first 5 ServiceRecord records ordered by the workerId field
        servicerecords = await ServiceRecord.prisma().find_many(
            take=5,
            order={
                'workerId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
        include: Optional[types.ServiceRecordInclude] = None,
        order: Optional[Union[types.ServiceRecordOrderByInput, List[types.ServiceRecordOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceRecordScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single ServiceRecord record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ServiceRecord filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceRecord model
        order
            Order the returned ServiceRecord records by any field
        distinct
            Filter ServiceRecord records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ServiceRecord
            The first ServiceRecord record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ServiceRecord record ordered by the dateTime field
        servicerecord = await ServiceRecord.prisma().find_first(
            skip=1,
            order={
                'dateTime': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
        include: Optional[types.ServiceRecordInclude] = None,
        order: Optional[Union[types.ServiceRecordOrderByInput, List[types.ServiceRecordOrderByInput]]] = None,
        distinct: Optional[List[types.ServiceRecordScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single ServiceRecord record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            ServiceRecord filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned ServiceRecord model
        order
            Order the returned ServiceRecord records by any field
        distinct
            Filter ServiceRecord records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.ServiceRecord
            The first ServiceRecord record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second ServiceRecord record ordered by the serviceId field
        servicerecord = await ServiceRecord.prisma().find_first_or_raise(
            skip=1,
            order={
                'serviceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.ServiceRecordUpdateInput,
        where: types.ServiceRecordWhereUniqueInput,
        include: Optional[types.ServiceRecordInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single ServiceRecord record.

        Parameters
        ----------
        data
            ServiceRecord record data specifying what to update
        where
            ServiceRecord filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The updated ServiceRecord record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        servicerecord = await ServiceRecord.prisma().update(
            where={
                'id': 'ieahjgeb',
            },
            data={
                # data to update the ServiceRecord record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.ServiceRecordWhereUniqueInput,
        data: types.ServiceRecordUpsertInput,
        include: Optional[types.ServiceRecordInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            ServiceRecord filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned ServiceRecord model

        Returns
        -------
        prisma.models.ServiceRecord
            The created or updated ServiceRecord record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        servicerecord = await ServiceRecord.prisma().upsert(
            where={
                'id': 'hfeeddceg',
            },
            data={
                'create': {
                    'id': 'hfeeddceg',
                    'clientId': 'bbgdigchd',
                    'workerId': 'dajcifgdi',
                    'dateTime': datetime.datetime.utcnow(),
                    'serviceId': 'ccedhdbj',
                    'officeId': 'bjaabjjjce',
                    'workCabinetId': 'cafhdcdcjd',
                    'updatedAt': datetime.datetime.utcnow(),
                },
                'update': {
                    'clientId': 'bbgdigchd',
                    'workerId': 'dajcifgdi',
                    'dateTime': datetime.datetime.utcnow(),
                    'serviceId': 'ccedhdbj',
                    'officeId': 'bjaabjjjce',
                    'workCabinetId': 'cafhdcdcjd',
                    'updatedAt': datetime.datetime.utcnow(),
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.ServiceRecordUpdateManyMutationInput,
        where: types.ServiceRecordWhereInput,
    ) -> int:
        """Update multiple ServiceRecord records

        Parameters
        ----------
        data
            ServiceRecord data to update the selected ServiceRecord records to
        where
            Filter to select the ServiceRecord records to update

        Returns
        -------
        int
            The total number of ServiceRecord records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all ServiceRecord records
        total = await ServiceRecord.prisma().update_many(
            data={
                'officeId': 'dbecgbbid'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
    ) -> int:
        """Count the number of ServiceRecord records present in the database

        Parameters
        ----------
        select
            Select the ServiceRecord fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ServiceRecord filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceRecordCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ServiceRecord.prisma().count()

        # results: prisma.types.ServiceRecordCountAggregateOutput
        results = await ServiceRecord.prisma().count(
            select={
                '_all': True,
                'workCabinetId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.ServiceRecordCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
    ) -> types.ServiceRecordCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.ServiceRecordCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.ServiceRecordWhereInput] = None,
        cursor: Optional[types.ServiceRecordWhereUniqueInput] = None,
    ) -> Union[int, types.ServiceRecordCountAggregateOutput]:
        """Count the number of ServiceRecord records present in the database

        Parameters
        ----------
        select
            Select the ServiceRecord fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            ServiceRecord filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.ServiceRecordCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await ServiceRecord.prisma().count()

        # results: prisma.types.ServiceRecordCountAggregateOutput
        results = await ServiceRecord.prisma().count(
            select={
                '_all': True,
                'result': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.ServiceRecordCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.ServiceRecordWhereInput] = None
    ) -> int:
        """Delete multiple ServiceRecord records.

        Parameters
        ----------
        where
            Optional ServiceRecord filter to find the records to be deleted

        Returns
        -------
        int
            The total number of ServiceRecord records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all ServiceRecord records
        total = await ServiceRecord.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.ServiceRecordScalarFieldKeys'],
        *,
        where: Optional['types.ServiceRecordWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.ServiceRecordAvgAggregateInput'] = None,
        sum: Optional['types.ServiceRecordSumAggregateInput'] = None,
        min: Optional['types.ServiceRecordMinAggregateInput'] = None,
        max: Optional['types.ServiceRecordMaxAggregateInput'] = None,
        having: Optional['types.ServiceRecordScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.ServiceRecordCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.ServiceRecordScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.ServiceRecordScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.ServiceRecordGroupByOutput']:
        """Group ServiceRecord records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar ServiceRecord fields to group records by
        where
            ServiceRecord filter to select records
        take
            Limit the maximum number of ServiceRecord records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.ServiceRecordGroupByOutput]
            A list of dictionaries representing the ServiceRecord record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group ServiceRecord records by createdAt values
        # and count how many records are in each group
        results = await ServiceRecord.prisma().group_by(
            ['createdAt'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.User]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await User.prisma().query_raw(
            'SELECT * FROM User WHERE id = $1',
            'cchghigae',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.User
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().query_first(
            'SELECT * FROM User WHERE lastName = $1',
            'ecdjjjhab',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserCreateInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Create a new User record.

        Parameters
        ----------
        data
            User record data
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created User record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a User record from just the required fields
        user = await User.prisma().create(
            data={
                # data to create a User record
                'id': 'biachfede',
                'lastName': 'fhgaibff',
                'firstName': 'cadajbcbca',
                'birthDate': datetime.datetime.utcnow(),
                'updatedAt': datetime.datetime.utcnow(),
                'login': 'bjheigfcdd',
                'email': 'bjejigcdcg',
                'password': 'bifiiibcah',
                'roleId': 'dbjibjdaa',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple User records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of User record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await User.prisma().create_many(
            data=[
                {
                    # data to create a User record
                    'id': 'dgijbdiaf',
                    'lastName': 'begfaigba',
                    'firstName': 'bdjiafcgjb',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                    'login': 'bficecgcfg',
                    'email': 'cbjjeedcj',
                    'password': 'dedgbbhja',
                    'roleId': 'cabiahchj',
                },
                {
                    # data to create a User record
                    'id': 'cgbeccfce',
                    'lastName': 'fcjcagef',
                    'firstName': 'bgdhaeacic',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                    'login': 'caffafcheh',
                    'email': 'fjjbegge',
                    'password': 'bdiifhbieb',
                    'roleId': 'cdcaejhgg',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single User record.

        Parameters
        ----------
        where
            User filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The deleted User record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().delete(
            where={
                'id': 'jbijgfbfj',
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique User record.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique(
            where={
                'id': 'ggfbeddia',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> _PrismaModelT:
        """Find a unique User record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            User filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The found User record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().find_unique_or_raise(
            where={
                'id': 'djjejdaj',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple User records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N results
        where
            User filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.User]
            The list of all User records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 User records
        users = await User.prisma().find_many(take=10)

        # find the first 5 User records ordered by the firstName field
        users = await User.prisma().find_many(
            take=5,
            order={
                'firstName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single User record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the middleName field
        user = await User.prisma().find_first(
            skip=1,
            order={
                'middleName': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
        include: Optional[types.UserInclude] = None,
        order: Optional[Union[types.UserOrderByInput, List[types.UserOrderByInput]]] = None,
        distinct: Optional[List[types.UserScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single User record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            User filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned User model
        order
            Order the returned User records by any field
        distinct
            Filter User records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.User
            The first User record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second User record ordered by the birthDate field
        user = await User.prisma().find_first_or_raise(
            skip=1,
            order={
                'birthDate': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserUpdateInput,
        where: types.UserWhereUniqueInput,
        include: Optional[types.UserInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single User record.

        Parameters
        ----------
        data
            User record data specifying what to update
        where
            User filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The updated User record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await User.prisma().update(
            where={
                'id': 'bjabbfceji',
            },
            data={
                # data to update the User record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserWhereUniqueInput,
        data: types.UserUpsertInput,
        include: Optional[types.UserInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            User filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned User model

        Returns
        -------
        prisma.models.User
            The created or updated User record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = await User.prisma().upsert(
            where={
                'id': 'bgchfbjibb',
            },
            data={
                'create': {
                    'id': 'bgchfbjibb',
                    'lastName': 'fcjcagef',
                    'firstName': 'bgdhaeacic',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                    'login': 'caffafcheh',
                    'email': 'fjjbegge',
                    'password': 'bdiifhbieb',
                    'roleId': 'cdcaejhgg',
                },
                'update': {
                    'lastName': 'fcjcagef',
                    'firstName': 'bgdhaeacic',
                    'birthDate': datetime.datetime.utcnow(),
                    'updatedAt': datetime.datetime.utcnow(),
                    'login': 'caffafcheh',
                    'email': 'fjjbegge',
                    'password': 'bdiifhbieb',
                    'roleId': 'cdcaejhgg',
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserUpdateManyMutationInput,
        where: types.UserWhereInput,
    ) -> int:
        """Update multiple User records

        Parameters
        ----------
        data
            User data to update the selected User records to
        where
            Filter to select the User records to update

        Returns
        -------
        int
            The total number of User records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all User records
        total = await User.prisma().update_many(
            data={
                'createdAt': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> int:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'updatedAt': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> types.UserCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserWhereInput] = None,
        cursor: Optional[types.UserWhereUniqueInput] = None,
    ) -> Union[int, types.UserCountAggregateOutput]:
        """Count the number of User records present in the database

        Parameters
        ----------
        select
            Select the User fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            User filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await User.prisma().count()

        # results: prisma.types.UserCountAggregateOutput
        results = await User.prisma().count(
            select={
                '_all': True,
                'login': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserWhereInput] = None
    ) -> int:
        """Delete multiple User records.

        Parameters
        ----------
        where
            Optional User filter to find the records to be deleted

        Returns
        -------
        int
            The total number of User records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all User records
        total = await User.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserScalarFieldKeys'],
        *,
        where: Optional['types.UserWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserAvgAggregateInput'] = None,
        sum: Optional['types.UserSumAggregateInput'] = None,
        min: Optional['types.UserMinAggregateInput'] = None,
        max: Optional['types.UserMaxAggregateInput'] = None,
        having: Optional['types.UserScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserGroupByOutput']:
        """Group User records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar User fields to group records by
        where
            User filter to select records
        take
            Limit the maximum number of User records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserGroupByOutput]
            A list of dictionaries representing the User record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group User records by email values
        # and count how many records are in each group
        results = await User.prisma().group_by(
            ['email'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class UserOnCabinetActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.UserOnCabinet]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await UserOnCabinet.prisma().query_raw(
            'SELECT * FROM UserOnCabinet WHERE cabinetId = $1',
            'bajecchdjc',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.UserOnCabinet
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await UserOnCabinet.prisma().query_first(
            'SELECT * FROM UserOnCabinet WHERE userId = $1',
            'dfgacajif',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.UserOnCabinetCreateInput,
        include: Optional[types.UserOnCabinetInclude] = None
    ) -> _PrismaModelT:
        """Create a new UserOnCabinet record.

        Parameters
        ----------
        data
            UserOnCabinet record data
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The created UserOnCabinet record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a UserOnCabinet record from just the required fields
        useroncabinet = await UserOnCabinet.prisma().create(
            data={
                # data to create a UserOnCabinet record
                'cabinetId': 'bgdiddfadi',
                'userId': 'bijbfghhhf',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.UserOnCabinetCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple UserOnCabinet records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of UserOnCabinet record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await UserOnCabinet.prisma().create_many(
            data=[
                {
                    # data to create a UserOnCabinet record
                    'cabinetId': 'bahchhihdc',
                    'userId': 'bihjdcibib',
                },
                {
                    # data to create a UserOnCabinet record
                    'cabinetId': 'bfhhjbbdha',
                    'userId': 'faehcjfdb',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.UserOnCabinetWhereUniqueInput,
        include: Optional[types.UserOnCabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single UserOnCabinet record.

        Parameters
        ----------
        where
            UserOnCabinet filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The deleted UserOnCabinet record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useroncabinet = await UserOnCabinet.prisma().delete(
            where={
                # UserOnCabinet where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.UserOnCabinetWhereUniqueInput,
        include: Optional[types.UserOnCabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique UserOnCabinet record.

        Parameters
        ----------
        where
            UserOnCabinet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The found UserOnCabinet record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useroncabinet = await UserOnCabinet.prisma().find_unique(
            where={
                # UserOnCabinet where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.UserOnCabinetWhereUniqueInput,
        include: Optional[types.UserOnCabinetInclude] = None
    ) -> _PrismaModelT:
        """Find a unique UserOnCabinet record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            UserOnCabinet filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The found UserOnCabinet record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useroncabinet = await UserOnCabinet.prisma().find_unique_or_raise(
            where={
                # UserOnCabinet where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
        include: Optional[types.UserOnCabinetInclude] = None,
        order: Optional[Union[types.UserOnCabinetOrderByInput, List[types.UserOnCabinetOrderByInput]]] = None,
        distinct: Optional[List[types.UserOnCabinetScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple UserOnCabinet records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of UserOnCabinet records returned
        skip
            Ignore the first N results
        where
            UserOnCabinet filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model
        order
            Order the returned UserOnCabinet records by any field
        distinct
            Filter UserOnCabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.UserOnCabinet]
            The list of all UserOnCabinet records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 UserOnCabinet records
        useroncabinets = await UserOnCabinet.prisma().find_many(take=10)

        # find the first 5 UserOnCabinet records ordered by the cabinetId field
        useroncabinets = await UserOnCabinet.prisma().find_many(
            take=5,
            order={
                'cabinetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
        include: Optional[types.UserOnCabinetInclude] = None,
        order: Optional[Union[types.UserOnCabinetOrderByInput, List[types.UserOnCabinetOrderByInput]]] = None,
        distinct: Optional[List[types.UserOnCabinetScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single UserOnCabinet record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserOnCabinet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model
        order
            Order the returned UserOnCabinet records by any field
        distinct
            Filter UserOnCabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserOnCabinet
            The first UserOnCabinet record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserOnCabinet record ordered by the userId field
        useroncabinet = await UserOnCabinet.prisma().find_first(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
        include: Optional[types.UserOnCabinetInclude] = None,
        order: Optional[Union[types.UserOnCabinetOrderByInput, List[types.UserOnCabinetOrderByInput]]] = None,
        distinct: Optional[List[types.UserOnCabinetScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single UserOnCabinet record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            UserOnCabinet filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model
        order
            Order the returned UserOnCabinet records by any field
        distinct
            Filter UserOnCabinet records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.UserOnCabinet
            The first UserOnCabinet record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second UserOnCabinet record ordered by the cabinetId field
        useroncabinet = await UserOnCabinet.prisma().find_first_or_raise(
            skip=1,
            order={
                'cabinetId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.UserOnCabinetUpdateInput,
        where: types.UserOnCabinetWhereUniqueInput,
        include: Optional[types.UserOnCabinetInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single UserOnCabinet record.

        Parameters
        ----------
        data
            UserOnCabinet record data specifying what to update
        where
            UserOnCabinet filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The updated UserOnCabinet record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        useroncabinet = await UserOnCabinet.prisma().update(
            where={
                # UserOnCabinet where unique filter

            },
            data={
                # data to update the UserOnCabinet record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.UserOnCabinetWhereUniqueInput,
        data: types.UserOnCabinetUpsertInput,
        include: Optional[types.UserOnCabinetInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            UserOnCabinet filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned UserOnCabinet model

        Returns
        -------
        prisma.models.UserOnCabinet
            The created or updated UserOnCabinet record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        useroncabinet = await UserOnCabinet.prisma().upsert(
            where={
                # UserOnCabinet where unique filter
            },
            data={
                'create': {
                    # UserOnCabinet data to be set if the record does not exist
                },
                'update': {
                    # UserOnCabinet data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.UserOnCabinetUpdateManyMutationInput,
        where: types.UserOnCabinetWhereInput,
    ) -> int:
        """Update multiple UserOnCabinet records

        Parameters
        ----------
        data
            UserOnCabinet data to update the selected UserOnCabinet records to
        where
            Filter to select the UserOnCabinet records to update

        Returns
        -------
        int
            The total number of UserOnCabinet records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all UserOnCabinet records
        total = await UserOnCabinet.prisma().update_many(
            data={
                'userId': 'bbaiefbee'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
    ) -> int:
        """Count the number of UserOnCabinet records present in the database

        Parameters
        ----------
        select
            Select the UserOnCabinet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserOnCabinet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserOnCabinetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserOnCabinet.prisma().count()

        # results: prisma.types.UserOnCabinetCountAggregateOutput
        results = await UserOnCabinet.prisma().count(
            select={
                '_all': True,
                'cabinetId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.UserOnCabinetCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
    ) -> types.UserOnCabinetCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.UserOnCabinetCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.UserOnCabinetWhereInput] = None,
        cursor: Optional[types.UserOnCabinetWhereUniqueInput] = None,
    ) -> Union[int, types.UserOnCabinetCountAggregateOutput]:
        """Count the number of UserOnCabinet records present in the database

        Parameters
        ----------
        select
            Select the UserOnCabinet fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            UserOnCabinet filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.UserOnCabinetCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await UserOnCabinet.prisma().count()

        # results: prisma.types.UserOnCabinetCountAggregateOutput
        results = await UserOnCabinet.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.UserOnCabinetCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.UserOnCabinetWhereInput] = None
    ) -> int:
        """Delete multiple UserOnCabinet records.

        Parameters
        ----------
        where
            Optional UserOnCabinet filter to find the records to be deleted

        Returns
        -------
        int
            The total number of UserOnCabinet records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all UserOnCabinet records
        total = await UserOnCabinet.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.UserOnCabinetScalarFieldKeys'],
        *,
        where: Optional['types.UserOnCabinetWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.UserOnCabinetAvgAggregateInput'] = None,
        sum: Optional['types.UserOnCabinetSumAggregateInput'] = None,
        min: Optional['types.UserOnCabinetMinAggregateInput'] = None,
        max: Optional['types.UserOnCabinetMaxAggregateInput'] = None,
        having: Optional['types.UserOnCabinetScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.UserOnCabinetCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.UserOnCabinetScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.UserOnCabinetScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.UserOnCabinetGroupByOutput']:
        """Group UserOnCabinet records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar UserOnCabinet fields to group records by
        where
            UserOnCabinet filter to select records
        take
            Limit the maximum number of UserOnCabinet records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.UserOnCabinetGroupByOutput]
            A list of dictionaries representing the UserOnCabinet record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group UserOnCabinet records by cabinetId values
        # and count how many records are in each group
        results = await UserOnCabinet.prisma().group_by(
            ['cabinetId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class WorkerOnServiceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    async def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.WorkerOnService]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = await WorkerOnService.prisma().query_raw(
            'SELECT * FROM WorkerOnService WHERE serviceId = $1',
            'bdaacgjbaf',
        )
        ```
        """
        return await self._client.query_raw(query, *args, model=self._model)

    async def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.WorkerOnService
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = await WorkerOnService.prisma().query_first(
            'SELECT * FROM WorkerOnService WHERE userId = $1',
            'biibaighec',
        )
        ```
        """
        return await self._client.query_first(query, *args, model=self._model)

    async def create(
        self,
        data: types.WorkerOnServiceCreateInput,
        include: Optional[types.WorkerOnServiceInclude] = None
    ) -> _PrismaModelT:
        """Create a new WorkerOnService record.

        Parameters
        ----------
        data
            WorkerOnService record data
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The created WorkerOnService record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a WorkerOnService record from just the required fields
        workeronservice = await WorkerOnService.prisma().create(
            data={
                # data to create a WorkerOnService record
                'serviceId': 'baicdfeidj',
                'userId': 'befgiciadg',
                'creatorId': 'cbcehahedh',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def create_many(
        self,
        data: List[types.WorkerOnServiceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple WorkerOnService records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of WorkerOnService record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = await WorkerOnService.prisma().create_many(
            data=[
                {
                    # data to create a WorkerOnService record
                    'serviceId': 'bcjihiaide',
                    'userId': 'bagfijcgfj',
                    'creatorId': 'bcggehiidc',
                },
                {
                    # data to create a WorkerOnService record
                    'serviceId': 'bjcdacgacf',
                    'userId': 'jfieeahi',
                    'creatorId': 'bijfjbddfj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if skip_duplicates and self._client._active_provider in CREATE_MANY_SKIP_DUPLICATES_UNSUPPORTED:
            raise errors.UnsupportedDatabaseError(self._client._active_provider, 'create_many_skip_duplicates')

        resp = await self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    async def delete(
        self,
        where: types.WorkerOnServiceWhereUniqueInput,
        include: Optional[types.WorkerOnServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single WorkerOnService record.

        Parameters
        ----------
        where
            WorkerOnService filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The deleted WorkerOnService record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workeronservice = await WorkerOnService.prisma().delete(
            where={
                # WorkerOnService where unique filter

            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def find_unique(
        self,
        where: types.WorkerOnServiceWhereUniqueInput,
        include: Optional[types.WorkerOnServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique WorkerOnService record.

        Parameters
        ----------
        where
            WorkerOnService filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The found WorkerOnService record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workeronservice = await WorkerOnService.prisma().find_unique(
            where={
                # WorkerOnService where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    async def find_unique_or_raise(
        self,
        where: types.WorkerOnServiceWhereUniqueInput,
        include: Optional[types.WorkerOnServiceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique WorkerOnService record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            WorkerOnService filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The found WorkerOnService record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workeronservice = await WorkerOnService.prisma().find_unique_or_raise(
            where={
                # WorkerOnService where unique filter

            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
        include: Optional[types.WorkerOnServiceInclude] = None,
        order: Optional[Union[types.WorkerOnServiceOrderByInput, List[types.WorkerOnServiceOrderByInput]]] = None,
        distinct: Optional[List[types.WorkerOnServiceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple WorkerOnService records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of WorkerOnService records returned
        skip
            Ignore the first N results
        where
            WorkerOnService filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkerOnService model
        order
            Order the returned WorkerOnService records by any field
        distinct
            Filter WorkerOnService records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.WorkerOnService]
            The list of all WorkerOnService records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 WorkerOnService records
        workeronservices = await WorkerOnService.prisma().find_many(take=10)

        # find the first 5 WorkerOnService records ordered by the creatorId field
        workeronservices = await WorkerOnService.prisma().find_many(
            take=5,
            order={
                'creatorId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    async def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
        include: Optional[types.WorkerOnServiceInclude] = None,
        order: Optional[Union[types.WorkerOnServiceOrderByInput, List[types.WorkerOnServiceOrderByInput]]] = None,
        distinct: Optional[List[types.WorkerOnServiceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single WorkerOnService record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkerOnService filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkerOnService model
        order
            Order the returned WorkerOnService records by any field
        distinct
            Filter WorkerOnService records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkerOnService
            The first WorkerOnService record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkerOnService record ordered by the serviceId field
        workeronservice = await WorkerOnService.prisma().find_first(
            skip=1,
            order={
                'serviceId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    async def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
        include: Optional[types.WorkerOnServiceInclude] = None,
        order: Optional[Union[types.WorkerOnServiceOrderByInput, List[types.WorkerOnServiceOrderByInput]]] = None,
        distinct: Optional[List[types.WorkerOnServiceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single WorkerOnService record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            WorkerOnService filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned WorkerOnService model
        order
            Order the returned WorkerOnService records by any field
        distinct
            Filter WorkerOnService records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.WorkerOnService
            The first WorkerOnService record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second WorkerOnService record ordered by the userId field
        workeronservice = await WorkerOnService.prisma().find_first_or_raise(
            skip=1,
            order={
                'userId': 'desc',
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update(
        self,
        data: types.WorkerOnServiceUpdateInput,
        where: types.WorkerOnServiceWhereUniqueInput,
        include: Optional[types.WorkerOnServiceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single WorkerOnService record.

        Parameters
        ----------
        data
            WorkerOnService record data specifying what to update
        where
            WorkerOnService filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The updated WorkerOnService record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        workeronservice = await WorkerOnService.prisma().update(
            where={
                # WorkerOnService where unique filter

            },
            data={
                # data to update the WorkerOnService record to
            },
        )
        ```
        """
        try:
            resp = await self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    async def upsert(
        self,
        where: types.WorkerOnServiceWhereUniqueInput,
        data: types.WorkerOnServiceUpsertInput,
        include: Optional[types.WorkerOnServiceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            WorkerOnService filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned WorkerOnService model

        Returns
        -------
        prisma.models.WorkerOnService
            The created or updated WorkerOnService record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        workeronservice = await WorkerOnService.prisma().upsert(
            where={
                # WorkerOnService where unique filter
            },
            data={
                'create': {
                    # WorkerOnService data to be set if the record does not exist
                },
                'update': {
                    # WorkerOnService data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = await self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    async def update_many(
        self,
        data: types.WorkerOnServiceUpdateManyMutationInput,
        where: types.WorkerOnServiceWhereInput,
    ) -> int:
        """Update multiple WorkerOnService records

        Parameters
        ----------
        data
            WorkerOnService data to update the selected WorkerOnService records to
        where
            Filter to select the WorkerOnService records to update

        Returns
        -------
        int
            The total number of WorkerOnService records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all WorkerOnService records
        total = await WorkerOnService.prisma().update_many(
            data={
                'creatorId': 'cdcdjdcee'
            },
            where={}
        )
        ```
        """
        resp = await self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    async def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of WorkerOnService records present in the database

        Parameters
        ----------
        select
            Select the WorkerOnService fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkerOnService filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkerOnServiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkerOnService.prisma().count()

        # results: prisma.types.WorkerOnServiceCountAggregateOutput
        results = await WorkerOnService.prisma().count(
            select={
                '_all': True,
                'serviceId': True,
            },
        )
        ```
        """


    @overload
    async def count(
        self,
        select: types.WorkerOnServiceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
    ) -> types.WorkerOnServiceCountAggregateOutput:
        ...

    async def count(
        self,
        select: Optional[types.WorkerOnServiceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.WorkerOnServiceWhereInput] = None,
        cursor: Optional[types.WorkerOnServiceWhereUniqueInput] = None,
    ) -> Union[int, types.WorkerOnServiceCountAggregateOutput]:
        """Count the number of WorkerOnService records present in the database

        Parameters
        ----------
        select
            Select the WorkerOnService fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            WorkerOnService filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.WorkerOnServiceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = await WorkerOnService.prisma().count()

        # results: prisma.types.WorkerOnServiceCountAggregateOutput
        results = await WorkerOnService.prisma().count(
            select={
                '_all': True,
                'userId': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = await self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.WorkerOnServiceCountAggregateOutput, resp['data']['result']['_count'])

    async def delete_many(
        self,
        where: Optional[types.WorkerOnServiceWhereInput] = None
    ) -> int:
        """Delete multiple WorkerOnService records.

        Parameters
        ----------
        where
            Optional WorkerOnService filter to find the records to be deleted

        Returns
        -------
        int
            The total number of WorkerOnService records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all WorkerOnService records
        total = await WorkerOnService.prisma().delete_many()
        ```
        """
        resp = await self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    async def group_by(
        self,
        by: List['types.WorkerOnServiceScalarFieldKeys'],
        *,
        where: Optional['types.WorkerOnServiceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.WorkerOnServiceAvgAggregateInput'] = None,
        sum: Optional['types.WorkerOnServiceSumAggregateInput'] = None,
        min: Optional['types.WorkerOnServiceMinAggregateInput'] = None,
        max: Optional['types.WorkerOnServiceMaxAggregateInput'] = None,
        having: Optional['types.WorkerOnServiceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.WorkerOnServiceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.WorkerOnServiceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.WorkerOnServiceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.WorkerOnServiceGroupByOutput']:
        """Group WorkerOnService records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar WorkerOnService fields to group records by
        where
            WorkerOnService filter to select records
        take
            Limit the maximum number of WorkerOnService records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.WorkerOnServiceGroupByOutput]
            A list of dictionaries representing the WorkerOnService record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group WorkerOnService records by creatorId values
        # and count how many records are in each group
        results = await WorkerOnService.prisma().group_by(
            ['creatorId'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = await self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models