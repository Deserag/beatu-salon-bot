# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class Cabinet(bases.BaseCabinet):
    """Represents a Cabinet record"""

    id: _str
    number: _str
    officeId: _str
    createdAt: datetime.datetime
    creatorId: _str
    deletedAt: Optional[datetime.datetime] = None
    updatedAt: datetime.datetime
    status: 'enums.ECabinetStatus'
    Office: Optional['models.Office'] = None
    Schedule: Optional[List['models.Schedule']] = None
    ServiceRecord: Optional[List['models.ServiceRecord']] = None
    UserOnCabinet: Optional[List['models.UserOnCabinet']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.CabinetKeys']] = None,
        exclude: Optional[Iterable['types.CabinetKeys']] = None,
        required: Optional[Iterable['types.CabinetKeys']] = None,
        optional: Optional[Iterable['types.CabinetKeys']] = None,
        relations: Optional[Mapping['types.CabinetRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.CabinetKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Cabinet_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Cabinet_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Cabinet_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Cabinet_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Cabinet_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Cabinet_relational_fields:
                        raise errors.UnknownRelationalFieldError('Cabinet', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Cabinet / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Cabinet',
            }
        )
        _created_partial_types.add(name)


class Client(bases.BaseClient):
    """Represents a Client record"""

    id: _str
    telegramId: _str
    firstName: _str
    lastName: _str
    middleName: Optional[_str] = None
    birthDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    ClientHistory: Optional[List['models.ClientHistory']] = None
    ProductSale: Optional[List['models.ProductSale']] = None
    Review: Optional[List['models.Review']] = None
    ServiceRecord: Optional[List['models.ServiceRecord']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ClientKeys']] = None,
        exclude: Optional[Iterable['types.ClientKeys']] = None,
        required: Optional[Iterable['types.ClientKeys']] = None,
        optional: Optional[Iterable['types.ClientKeys']] = None,
        relations: Optional[Mapping['types.ClientRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ClientKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Client_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Client_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Client_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Client_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Client_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Client_relational_fields:
                        raise errors.UnknownRelationalFieldError('Client', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Client / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Client',
            }
        )
        _created_partial_types.add(name)


class ClientHistory(bases.BaseClientHistory):
    """Represents a ClientHistory record"""

    id: _str
    clientId: _str
    serviceId: _str
    date: datetime.datetime
    feedbackId: Optional[_str] = None
    Client: Optional['models.Client'] = None
    Review: Optional['models.Review'] = None
    Service: Optional['models.Service'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ClientHistoryKeys']] = None,
        exclude: Optional[Iterable['types.ClientHistoryKeys']] = None,
        required: Optional[Iterable['types.ClientHistoryKeys']] = None,
        optional: Optional[Iterable['types.ClientHistoryKeys']] = None,
        relations: Optional[Mapping['types.ClientHistoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ClientHistoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ClientHistory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ClientHistory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ClientHistory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ClientHistory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ClientHistory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ClientHistory_relational_fields:
                        raise errors.UnknownRelationalFieldError('ClientHistory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ClientHistory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ClientHistory',
            }
        )
        _created_partial_types.add(name)


class Department(bases.BaseDepartment):
    """Represents a Department record"""

    id: _str
    name: _str
    description: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    DepartmentUser: Optional[List['models.DepartmentUser']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DepartmentKeys']] = None,
        exclude: Optional[Iterable['types.DepartmentKeys']] = None,
        required: Optional[Iterable['types.DepartmentKeys']] = None,
        optional: Optional[Iterable['types.DepartmentKeys']] = None,
        relations: Optional[Mapping['types.DepartmentRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DepartmentKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Department_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Department_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Department_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Department_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Department_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Department_relational_fields:
                        raise errors.UnknownRelationalFieldError('Department', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Department / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Department',
            }
        )
        _created_partial_types.add(name)


class DepartmentUser(bases.BaseDepartmentUser):
    """Represents a DepartmentUser record"""

    userId: _str
    departmentId: _str
    Department: Optional['models.Department'] = None
    User: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.DepartmentUserKeys']] = None,
        exclude: Optional[Iterable['types.DepartmentUserKeys']] = None,
        required: Optional[Iterable['types.DepartmentUserKeys']] = None,
        optional: Optional[Iterable['types.DepartmentUserKeys']] = None,
        relations: Optional[Mapping['types.DepartmentUserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.DepartmentUserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _DepartmentUser_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _DepartmentUser_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _DepartmentUser_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _DepartmentUser_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _DepartmentUser_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _DepartmentUser_relational_fields:
                        raise errors.UnknownRelationalFieldError('DepartmentUser', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid DepartmentUser / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'DepartmentUser',
            }
        )
        _created_partial_types.add(name)


class Office(bases.BaseOffice):
    """Represents a Office record"""

    id: _str
    number: _str
    address: _str
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    creatorId: _str
    Cabinet: Optional[List['models.Cabinet']] = None
    ServiceRecord: Optional[List['models.ServiceRecord']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OfficeKeys']] = None,
        exclude: Optional[Iterable['types.OfficeKeys']] = None,
        required: Optional[Iterable['types.OfficeKeys']] = None,
        optional: Optional[Iterable['types.OfficeKeys']] = None,
        relations: Optional[Mapping['types.OfficeRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OfficeKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Office_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Office_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Office_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Office_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Office_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Office_relational_fields:
                        raise errors.UnknownRelationalFieldError('Office', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Office / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Office',
            }
        )
        _created_partial_types.add(name)


class Opportunity(bases.BaseOpportunity):
    """Represents a Opportunity record"""

    id: _str
    name: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.OpportunityKeys']] = None,
        exclude: Optional[Iterable['types.OpportunityKeys']] = None,
        required: Optional[Iterable['types.OpportunityKeys']] = None,
        optional: Optional[Iterable['types.OpportunityKeys']] = None,
        relations: Optional[Mapping['types.OpportunityRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.OpportunityKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Opportunity_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Opportunity_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Opportunity_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Opportunity_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Opportunity" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Opportunity / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Opportunity',
            }
        )
        _created_partial_types.add(name)


class Position(bases.BasePosition):
    """Represents a Position record"""

    id: _str
    name: _str
    description: Optional[_str] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.PositionKeys']] = None,
        exclude: Optional[Iterable['types.PositionKeys']] = None,
        required: Optional[Iterable['types.PositionKeys']] = None,
        optional: Optional[Iterable['types.PositionKeys']] = None,
        relations: Optional[Mapping['types.PositionRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.PositionKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Position_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Position_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Position_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Position_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True


            if relations:
                raise ValueError('Model: "Position" has no relational fields.')
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Position / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Position',
            }
        )
        _created_partial_types.add(name)


class Product(bases.BaseProduct):
    """Represents a Product record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    volume: _float
    unit: _str
    quantity: _int
    prices: _int
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    creatorId: _str
    User: Optional['models.User'] = None
    ProductSale: Optional[List['models.ProductSale']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProductKeys']] = None,
        exclude: Optional[Iterable['types.ProductKeys']] = None,
        required: Optional[Iterable['types.ProductKeys']] = None,
        optional: Optional[Iterable['types.ProductKeys']] = None,
        relations: Optional[Mapping['types.ProductRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProductKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Product_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Product_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Product_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Product_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Product_relational_fields:
                        raise errors.UnknownRelationalFieldError('Product', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Product / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Product',
            }
        )
        _created_partial_types.add(name)


class ProductSale(bases.BaseProductSale):
    """Represents a ProductSale record"""

    id: _str
    productId: _str
    clientId: _str
    quantity: _int
    price: _float
    totalPrice: _float
    saleDate: datetime.datetime
    creatorId: _str
    Client: Optional['models.Client'] = None
    Product: Optional['models.Product'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ProductSaleKeys']] = None,
        exclude: Optional[Iterable['types.ProductSaleKeys']] = None,
        required: Optional[Iterable['types.ProductSaleKeys']] = None,
        optional: Optional[Iterable['types.ProductSaleKeys']] = None,
        relations: Optional[Mapping['types.ProductSaleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ProductSaleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ProductSale_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ProductSale_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ProductSale_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ProductSale_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ProductSale_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ProductSale_relational_fields:
                        raise errors.UnknownRelationalFieldError('ProductSale', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ProductSale / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ProductSale',
            }
        )
        _created_partial_types.add(name)


class Review(bases.BaseReview):
    """Represents a Review record"""

    id: _str
    serviceId: _str
    clientId: _str
    comment: Optional[_str] = None
    grade: 'enums.EGrade'
    ClientHistory: Optional[List['models.ClientHistory']] = None
    Client: Optional['models.Client'] = None
    Service: Optional['models.Service'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ReviewKeys']] = None,
        exclude: Optional[Iterable['types.ReviewKeys']] = None,
        required: Optional[Iterable['types.ReviewKeys']] = None,
        optional: Optional[Iterable['types.ReviewKeys']] = None,
        relations: Optional[Mapping['types.ReviewRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Review_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Review_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Review_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Review_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Review_relational_fields:
                        raise errors.UnknownRelationalFieldError('Review', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Review / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Review',
            }
        )
        _created_partial_types.add(name)


class Role(bases.BaseRole):
    """Represents a Role record"""

    id: _str
    name: _str
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    updatedAt: datetime.datetime
    description: _str
    User: Optional[List['models.User']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.RoleKeys']] = None,
        exclude: Optional[Iterable['types.RoleKeys']] = None,
        required: Optional[Iterable['types.RoleKeys']] = None,
        optional: Optional[Iterable['types.RoleKeys']] = None,
        relations: Optional[Mapping['types.RoleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Role_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Role_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Role_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Role_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Role_relational_fields:
                        raise errors.UnknownRelationalFieldError('Role', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Role / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Role',
            }
        )
        _created_partial_types.add(name)


class Schedule(bases.BaseSchedule):
    """Represents a Schedule record"""

    id: _str
    date: datetime.datetime
    startTime: datetime.datetime
    endTime: datetime.datetime
    userId: _str
    cabinetId: _str
    Cabinet: Optional['models.Cabinet'] = None
    User: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ScheduleKeys']] = None,
        exclude: Optional[Iterable['types.ScheduleKeys']] = None,
        required: Optional[Iterable['types.ScheduleKeys']] = None,
        optional: Optional[Iterable['types.ScheduleKeys']] = None,
        relations: Optional[Mapping['types.ScheduleRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ScheduleKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Schedule_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Schedule_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Schedule_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Schedule_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Schedule_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Schedule_relational_fields:
                        raise errors.UnknownRelationalFieldError('Schedule', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Schedule / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Schedule',
            }
        )
        _created_partial_types.add(name)


class Service(bases.BaseService):
    """Represents a Service record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    price: _int
    duration: _float
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    creatorId: _str
    ClientHistory: Optional[List['models.ClientHistory']] = None
    Review: Optional[List['models.Review']] = None
    ServiceRecord: Optional[List['models.ServiceRecord']] = None
    WorkerOnService: Optional[List['models.WorkerOnService']] = None
    ServiceCategory: Optional[List['models.ServiceCategory']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ServiceKeys']] = None,
        exclude: Optional[Iterable['types.ServiceKeys']] = None,
        required: Optional[Iterable['types.ServiceKeys']] = None,
        optional: Optional[Iterable['types.ServiceKeys']] = None,
        relations: Optional[Mapping['types.ServiceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ServiceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _Service_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _Service_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _Service_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _Service_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _Service_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _Service_relational_fields:
                        raise errors.UnknownRelationalFieldError('Service', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid Service / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'Service',
            }
        )
        _created_partial_types.add(name)


class ServiceCategory(bases.BaseServiceCategory):
    """Represents a ServiceCategory record"""

    id: _str
    name: _str
    description: Optional[_str] = None
    Service: Optional[List['models.Service']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ServiceCategoryKeys']] = None,
        exclude: Optional[Iterable['types.ServiceCategoryKeys']] = None,
        required: Optional[Iterable['types.ServiceCategoryKeys']] = None,
        optional: Optional[Iterable['types.ServiceCategoryKeys']] = None,
        relations: Optional[Mapping['types.ServiceCategoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ServiceCategoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ServiceCategory_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ServiceCategory_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ServiceCategory_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ServiceCategory_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ServiceCategory_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ServiceCategory_relational_fields:
                        raise errors.UnknownRelationalFieldError('ServiceCategory', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ServiceCategory / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ServiceCategory',
            }
        )
        _created_partial_types.add(name)


class ServiceRecord(bases.BaseServiceRecord):
    """Represents a ServiceRecord record"""

    id: _str
    clientId: _str
    workerId: _str
    dateTime: datetime.datetime
    serviceId: _str
    officeId: _str
    workCabinetId: _str
    result: Optional[_str] = None
    createdAt: datetime.datetime
    deletedAt: Optional[datetime.datetime] = None
    updatedAt: datetime.datetime
    Client: Optional['models.Client'] = None
    Office: Optional['models.Office'] = None
    Service: Optional['models.Service'] = None
    Cabinet: Optional['models.Cabinet'] = None
    User: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.ServiceRecordKeys']] = None,
        exclude: Optional[Iterable['types.ServiceRecordKeys']] = None,
        required: Optional[Iterable['types.ServiceRecordKeys']] = None,
        optional: Optional[Iterable['types.ServiceRecordKeys']] = None,
        relations: Optional[Mapping['types.ServiceRecordRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.ServiceRecordKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _ServiceRecord_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _ServiceRecord_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _ServiceRecord_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _ServiceRecord_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _ServiceRecord_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _ServiceRecord_relational_fields:
                        raise errors.UnknownRelationalFieldError('ServiceRecord', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid ServiceRecord / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'ServiceRecord',
            }
        )
        _created_partial_types.add(name)


class User(bases.BaseUser):
    """Represents a User record"""

    id: _str
    lastName: _str
    firstName: _str
    middleName: Optional[_str] = None
    birthDate: datetime.datetime
    createdAt: datetime.datetime
    updatedAt: datetime.datetime
    login: _str
    email: _str
    password: _str
    roleId: _str
    telegramId: Optional[_str] = None
    DepartmentUser: Optional[List['models.DepartmentUser']] = None
    Product: Optional[List['models.Product']] = None
    Schedule: Optional[List['models.Schedule']] = None
    ServiceRecord: Optional[List['models.ServiceRecord']] = None
    Role: Optional['models.Role'] = None
    UserOnCabinet: Optional[List['models.UserOnCabinet']] = None
    WorkerOnService_WorkerOnService_creatorIdToUser: Optional[List['models.WorkerOnService']] = None
    WorkerOnService_WorkerOnService_userIdToUser: Optional[List['models.WorkerOnService']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserKeys']] = None,
        exclude: Optional[Iterable['types.UserKeys']] = None,
        required: Optional[Iterable['types.UserKeys']] = None,
        optional: Optional[Iterable['types.UserKeys']] = None,
        relations: Optional[Mapping['types.UserRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _User_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _User_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _User_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _User_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _User_relational_fields:
                        raise errors.UnknownRelationalFieldError('User', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid User / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'User',
            }
        )
        _created_partial_types.add(name)


class UserOnCabinet(bases.BaseUserOnCabinet):
    """Represents a UserOnCabinet record"""

    cabinetId: _str
    userId: _str
    Cabinet: Optional['models.Cabinet'] = None
    User: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.UserOnCabinetKeys']] = None,
        exclude: Optional[Iterable['types.UserOnCabinetKeys']] = None,
        required: Optional[Iterable['types.UserOnCabinetKeys']] = None,
        optional: Optional[Iterable['types.UserOnCabinetKeys']] = None,
        relations: Optional[Mapping['types.UserOnCabinetRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.UserOnCabinetKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _UserOnCabinet_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _UserOnCabinet_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _UserOnCabinet_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _UserOnCabinet_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _UserOnCabinet_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _UserOnCabinet_relational_fields:
                        raise errors.UnknownRelationalFieldError('UserOnCabinet', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid UserOnCabinet / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'UserOnCabinet',
            }
        )
        _created_partial_types.add(name)


class WorkerOnService(bases.BaseWorkerOnService):
    """Represents a WorkerOnService record"""

    serviceId: _str
    userId: _str
    creatorId: _str
    User_WorkerOnService_creatorIdToUser: Optional['models.User'] = None
    Service: Optional['models.Service'] = None
    User_WorkerOnService_userIdToUser: Optional['models.User'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.WorkerOnServiceKeys']] = None,
        exclude: Optional[Iterable['types.WorkerOnServiceKeys']] = None,
        required: Optional[Iterable['types.WorkerOnServiceKeys']] = None,
        optional: Optional[Iterable['types.WorkerOnServiceKeys']] = None,
        relations: Optional[Mapping['types.WorkerOnServiceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.WorkerOnServiceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _WorkerOnService_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _WorkerOnService_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _WorkerOnService_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _WorkerOnService_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _WorkerOnService_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _WorkerOnService_relational_fields:
                        raise errors.UnknownRelationalFieldError('WorkerOnService', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid WorkerOnService / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'WorkerOnService',
            }
        )
        _created_partial_types.add(name)



_Cabinet_relational_fields: Set[str] = {
        'Office',
        'Schedule',
        'ServiceRecord',
        'UserOnCabinet',
    }
_Cabinet_fields: Dict['types.CabinetKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('number', {
            'name': 'number',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('officeId', {
            'name': 'officeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': 'enums.ECabinetStatus',
            'is_relational': False,
            'documentation': None,
        }),
        ('Office', {
            'name': 'Office',
            'is_list': False,
            'optional': True,
            'type': 'models.Office',
            'is_relational': True,
            'documentation': None,
        }),
        ('Schedule', {
            'name': 'Schedule',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Schedule\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceRecord', {
            'name': 'ServiceRecord',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('UserOnCabinet', {
            'name': 'UserOnCabinet',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserOnCabinet\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Client_relational_fields: Set[str] = {
        'ClientHistory',
        'ProductSale',
        'Review',
        'ServiceRecord',
    }
_Client_fields: Dict['types.ClientKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('telegramId', {
            'name': 'telegramId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstName', {
            'name': 'firstName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastName', {
            'name': 'lastName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('middleName', {
            'name': 'middleName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthDate', {
            'name': 'birthDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('ClientHistory', {
            'name': 'ClientHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ClientHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ProductSale', {
            'name': 'ProductSale',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProductSale\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Review', {
            'name': 'Review',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceRecord', {
            'name': 'ServiceRecord',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ClientHistory_relational_fields: Set[str] = {
        'Client',
        'Review',
        'Service',
    }
_ClientHistory_fields: Dict['types.ClientHistoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientId', {
            'name': 'clientId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('serviceId', {
            'name': 'serviceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('feedbackId', {
            'name': 'feedbackId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Client', {
            'name': 'Client',
            'is_list': False,
            'optional': True,
            'type': 'models.Client',
            'is_relational': True,
            'documentation': None,
        }),
        ('Review', {
            'name': 'Review',
            'is_list': False,
            'optional': True,
            'type': 'models.Review',
            'is_relational': True,
            'documentation': None,
        }),
        ('Service', {
            'name': 'Service',
            'is_list': False,
            'optional': True,
            'type': 'models.Service',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Department_relational_fields: Set[str] = {
        'DepartmentUser',
    }
_Department_fields: Dict['types.DepartmentKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('DepartmentUser', {
            'name': 'DepartmentUser',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DepartmentUser\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_DepartmentUser_relational_fields: Set[str] = {
        'Department',
        'User',
    }
_DepartmentUser_fields: Dict['types.DepartmentUserKeys', PartialModelField] = OrderedDict(
    [
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('departmentId', {
            'name': 'departmentId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Department', {
            'name': 'Department',
            'is_list': False,
            'optional': True,
            'type': 'models.Department',
            'is_relational': True,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Office_relational_fields: Set[str] = {
        'Cabinet',
        'ServiceRecord',
    }
_Office_fields: Dict['types.OfficeKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('number', {
            'name': 'number',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('address', {
            'name': 'address',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Cabinet', {
            'name': 'Cabinet',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Cabinet\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceRecord', {
            'name': 'ServiceRecord',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Opportunity_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Opportunity_fields: Dict['types.OpportunityKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Position_relational_fields: Set[str] = set()  # pyright: ignore[reportUnusedVariable]
_Position_fields: Dict['types.PositionKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_Product_relational_fields: Set[str] = {
        'User',
        'ProductSale',
    }
_Product_fields: Dict['types.ProductKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('volume', {
            'name': 'volume',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('unit', {
            'name': 'unit',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('prices', {
            'name': 'prices',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('ProductSale', {
            'name': 'ProductSale',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ProductSale\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ProductSale_relational_fields: Set[str] = {
        'Client',
        'Product',
    }
_ProductSale_fields: Dict['types.ProductSaleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('productId', {
            'name': 'productId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientId', {
            'name': 'clientId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('quantity', {
            'name': 'quantity',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('totalPrice', {
            'name': 'totalPrice',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('saleDate', {
            'name': 'saleDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Client', {
            'name': 'Client',
            'is_list': False,
            'optional': True,
            'type': 'models.Client',
            'is_relational': True,
            'documentation': None,
        }),
        ('Product', {
            'name': 'Product',
            'is_list': False,
            'optional': True,
            'type': 'models.Product',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Review_relational_fields: Set[str] = {
        'ClientHistory',
        'Client',
        'Service',
    }
_Review_fields: Dict['types.ReviewKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('serviceId', {
            'name': 'serviceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientId', {
            'name': 'clientId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('comment', {
            'name': 'comment',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('grade', {
            'name': 'grade',
            'is_list': False,
            'optional': False,
            'type': 'enums.EGrade',
            'is_relational': False,
            'documentation': None,
        }),
        ('ClientHistory', {
            'name': 'ClientHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ClientHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Client', {
            'name': 'Client',
            'is_list': False,
            'optional': True,
            'type': 'models.Client',
            'is_relational': True,
            'documentation': None,
        }),
        ('Service', {
            'name': 'Service',
            'is_list': False,
            'optional': True,
            'type': 'models.Service',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Role_relational_fields: Set[str] = {
        'User',
    }
_Role_fields: Dict['types.RoleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.User\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Schedule_relational_fields: Set[str] = {
        'Cabinet',
        'User',
    }
_Schedule_fields: Dict['types.ScheduleKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('date', {
            'name': 'date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('startTime', {
            'name': 'startTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('endTime', {
            'name': 'endTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('cabinetId', {
            'name': 'cabinetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Cabinet', {
            'name': 'Cabinet',
            'is_list': False,
            'optional': True,
            'type': 'models.Cabinet',
            'is_relational': True,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_Service_relational_fields: Set[str] = {
        'ClientHistory',
        'Review',
        'ServiceRecord',
        'WorkerOnService',
        'ServiceCategory',
    }
_Service_fields: Dict['types.ServiceKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('price', {
            'name': 'price',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('duration', {
            'name': 'duration',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('ClientHistory', {
            'name': 'ClientHistory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ClientHistory\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Review', {
            'name': 'Review',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Review\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceRecord', {
            'name': 'ServiceRecord',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('WorkerOnService', {
            'name': 'WorkerOnService',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WorkerOnService\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceCategory', {
            'name': 'ServiceCategory',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceCategory\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ServiceCategory_relational_fields: Set[str] = {
        'Service',
    }
_ServiceCategory_fields: Dict['types.ServiceCategoryKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Service', {
            'name': 'Service',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Service\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_ServiceRecord_relational_fields: Set[str] = {
        'Client',
        'Office',
        'Service',
        'Cabinet',
        'User',
    }
_ServiceRecord_fields: Dict['types.ServiceRecordKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('clientId', {
            'name': 'clientId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('workerId', {
            'name': 'workerId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('dateTime', {
            'name': 'dateTime',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('serviceId', {
            'name': 'serviceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('officeId', {
            'name': 'officeId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('workCabinetId', {
            'name': 'workCabinetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('result', {
            'name': 'result',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('deletedAt', {
            'name': 'deletedAt',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('Client', {
            'name': 'Client',
            'is_list': False,
            'optional': True,
            'type': 'models.Client',
            'is_relational': True,
            'documentation': None,
        }),
        ('Office', {
            'name': 'Office',
            'is_list': False,
            'optional': True,
            'type': 'models.Office',
            'is_relational': True,
            'documentation': None,
        }),
        ('Service', {
            'name': 'Service',
            'is_list': False,
            'optional': True,
            'type': 'models.Service',
            'is_relational': True,
            'documentation': None,
        }),
        ('Cabinet', {
            'name': 'Cabinet',
            'is_list': False,
            'optional': True,
            'type': 'models.Cabinet',
            'is_relational': True,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_User_relational_fields: Set[str] = {
        'DepartmentUser',
        'Product',
        'Schedule',
        'ServiceRecord',
        'Role',
        'UserOnCabinet',
        'WorkerOnService_WorkerOnService_creatorIdToUser',
        'WorkerOnService_WorkerOnService_userIdToUser',
    }
_User_fields: Dict['types.UserKeys', PartialModelField] = OrderedDict(
    [
        ('id', {
            'name': 'id',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('lastName', {
            'name': 'lastName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('firstName', {
            'name': 'firstName',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('middleName', {
            'name': 'middleName',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('birthDate', {
            'name': 'birthDate',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('createdAt', {
            'name': 'createdAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('updatedAt', {
            'name': 'updatedAt',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('login', {
            'name': 'login',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('roleId', {
            'name': 'roleId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('telegramId', {
            'name': 'telegramId',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('DepartmentUser', {
            'name': 'DepartmentUser',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.DepartmentUser\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Product', {
            'name': 'Product',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Product\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Schedule', {
            'name': 'Schedule',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.Schedule\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('ServiceRecord', {
            'name': 'ServiceRecord',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.ServiceRecord\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('Role', {
            'name': 'Role',
            'is_list': False,
            'optional': True,
            'type': 'models.Role',
            'is_relational': True,
            'documentation': None,
        }),
        ('UserOnCabinet', {
            'name': 'UserOnCabinet',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.UserOnCabinet\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('WorkerOnService_WorkerOnService_creatorIdToUser', {
            'name': 'WorkerOnService_WorkerOnService_creatorIdToUser',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WorkerOnService\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('WorkerOnService_WorkerOnService_userIdToUser', {
            'name': 'WorkerOnService_WorkerOnService_userIdToUser',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.WorkerOnService\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_UserOnCabinet_relational_fields: Set[str] = {
        'Cabinet',
        'User',
    }
_UserOnCabinet_fields: Dict['types.UserOnCabinetKeys', PartialModelField] = OrderedDict(
    [
        ('cabinetId', {
            'name': 'cabinetId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('Cabinet', {
            'name': 'Cabinet',
            'is_list': False,
            'optional': True,
            'type': 'models.Cabinet',
            'is_relational': True,
            'documentation': None,
        }),
        ('User', {
            'name': 'User',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_WorkerOnService_relational_fields: Set[str] = {
        'User_WorkerOnService_creatorIdToUser',
        'Service',
        'User_WorkerOnService_userIdToUser',
    }
_WorkerOnService_fields: Dict['types.WorkerOnServiceKeys', PartialModelField] = OrderedDict(
    [
        ('serviceId', {
            'name': 'serviceId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('userId', {
            'name': 'userId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('creatorId', {
            'name': 'creatorId',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('User_WorkerOnService_creatorIdToUser', {
            'name': 'User_WorkerOnService_creatorIdToUser',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
        ('Service', {
            'name': 'Service',
            'is_list': False,
            'optional': True,
            'type': 'models.Service',
            'is_relational': True,
            'documentation': None,
        }),
        ('User_WorkerOnService_userIdToUser', {
            'name': 'User_WorkerOnService_userIdToUser',
            'is_list': False,
            'optional': True,
            'type': 'models.User',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(Cabinet)
model_rebuild(Client)
model_rebuild(ClientHistory)
model_rebuild(Department)
model_rebuild(DepartmentUser)
model_rebuild(Office)
model_rebuild(Opportunity)
model_rebuild(Position)
model_rebuild(Product)
model_rebuild(ProductSale)
model_rebuild(Review)
model_rebuild(Role)
model_rebuild(Schedule)
model_rebuild(Service)
model_rebuild(ServiceCategory)
model_rebuild(ServiceRecord)
model_rebuild(User)
model_rebuild(UserOnCabinet)
model_rebuild(WorkerOnService)
